<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赵帅的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-10-27T12:01:07.236Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>赵帅</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis数据类型及操作</title>
    <link href="http://example.com/2020/10/27/Redis/redis2/"/>
    <id>http://example.com/2020/10/27/Redis/redis2/</id>
    <published>2020-10-27T12:00:14.696Z</published>
    <updated>2020-10-27T12:01:07.236Z</updated>
    
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>集合</title>
    <link href="http://example.com/2020/09/24/On%20Java8/%E9%9B%86%E5%90%88/"/>
    <id>http://example.com/2020/09/24/On%20Java8/%E9%9B%86%E5%90%88/</id>
    <published>2020-09-24T09:07:50.559Z</published>
    <updated>2020-09-25T06:23:36.859Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集合："><a href="#集合：" class="headerlink" title="集合："></a>集合：</h1><p>List、Set、Queue（队列） 映射：Map</p><h1 id="栈（Stack）：后进先出"><a href="#栈（Stack）：后进先出" class="headerlink" title="栈（Stack）：后进先出"></a>栈（Stack）：后进先出</h1><p>压入（push）、出栈（pop）</p><p>java6加入ArrayDeque替代Stack：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackTest</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Deque&lt;String&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-keyword">for</span>(String s : <span class="hljs-string">&quot;My dog has fleas&quot;</span>.split(<span class="hljs-string">&quot; &quot;</span>))      stack.push(s);    <span class="hljs-keyword">while</span>(!stack.isEmpty())      System.out.print(stack.pop() + <span class="hljs-string">&quot; &quot;</span>);  &#125;&#125;<span class="hljs-comment">/* Output:</span><span class="hljs-comment">fleas has dog My</span><span class="hljs-comment">*/</span></code></pre><h1 id="队列Queue："><a href="#队列Queue：" class="headerlink" title="队列Queue："></a>队列Queue：</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;集合：&quot;&gt;&lt;a href=&quot;#集合：&quot; class=&quot;headerlink&quot; title=&quot;集合：&quot;&gt;&lt;/a&gt;集合：&lt;/h1&gt;&lt;p&gt;List、Set、Queue（队列） 映射：Map&lt;/p&gt;
&lt;h1 id=&quot;栈（Stack）：后进先出&quot;&gt;&lt;a href=&quot;#栈（S</summary>
      
    
    
    
    <category term="On java8" scheme="http://example.com/categories/On-java8/"/>
    
    
    <category term="On java" scheme="http://example.com/tags/On-java/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据类型及操作</title>
    <link href="http://example.com/2020/09/23/Redis/Redis/"/>
    <id>http://example.com/2020/09/23/Redis/Redis/</id>
    <published>2020-09-23T13:29:17.600Z</published>
    <updated>2020-10-27T11:59:04.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis五大数据类型："><a href="#Redis五大数据类型：" class="headerlink" title="Redis五大数据类型："></a>Redis五大数据类型：</h1><p>String（字符串）、Hash（哈希，类似java中的Map）、List（列表）、Set（集合）、Zset（sorted set,有序集合）</p><h1 id="操作命令："><a href="#操作命令：" class="headerlink" title="操作命令："></a>操作命令：</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>DEL key</td><td>该命令用于在 key 存在时删除 key。</td></tr><tr><td>DUMP key</td><td>序列化给定 key ，并返回被序列化的值。</td></tr><tr><td>EXISTS key</td><td>检查给定 key 是否存在。</td></tr><tr><td>EXPIRE key seconds</td><td>为给定 key 设置过期时间，以秒计。</td></tr><tr><td>EXPIREAT key timestamp</td><td>EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</td></tr><tr><td>PEXPIRE key milliseconds</td><td>设置 key 的过期时间以毫秒计。</td></tr><tr><td>PEXPIREAT key milliseconds-timestamp</td><td>设置 key 过期时间的时间戳(unix timestamp) 以毫秒计</td></tr><tr><td>KEYS pattern</td><td>查找所有符合给定模式( pattern)的 key 。</td></tr><tr><td>MOVE key db</td><td>将当前数据库的 key 移动到给定的数据库 db 当中。</td></tr><tr><td>PERSIST key</td><td>移除 key 的过期时间，key 将持久保持。</td></tr><tr><td>PTTL key</td><td>以毫秒为单位返回 key 的剩余的过期时间。</td></tr><tr><td>TTL key</td><td>以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。</td></tr><tr><td>RANDOMKEY</td><td>从当前数据库中随机返回一个 key 。</td></tr><tr><td>RENAME key newkey</td><td>修改 key 的名称</td></tr><tr><td>RENAMENX key newkey</td><td>仅当 newkey 不存在时，将 key 改名为 newkey 。</td></tr><tr><td>SCAN cursor [MATCH pattern] [COUNT count]</td><td>迭代数据库中的数据库键。</td></tr><tr><td>TYPE key</td><td>返回 key 所储存的值的类型。</td></tr></tbody></table><h2 id="key："><a href="#key：" class="headerlink" title="key："></a>key：</h2><pre><code class="hljs routeros">Keys * :查询所有键值exists key的名字:判断某个key是否存在move key的名字 db库的标号：将该库的键值移动到标号库，该库移除exprie key的名字 秒钟：设置键的过期时间，过期将被移除ttl key:查看剩余多长时间过期，-1永不过期，-2已过期type key:查看key为什么类型</code></pre><p><img src="/blogimg/image-20200925093842215.png" alt="image-20200925093842215"></p><h2 id="String："><a href="#String：" class="headerlink" title="String："></a>String：</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>SET key value</td><td>设置指定 key 的值</td></tr><tr><td>GET key</td><td>获取指定 key 的值。</td></tr><tr><td>GETRANGE key start end</td><td>返回 key 中字符串值的子字符</td></tr><tr><td>GETSET key value</td><td>将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</td></tr><tr><td>GETBIT key offset</td><td>对 key 所储存的字符串值，获取指定偏移量上的位(bit)。</td></tr><tr><td>MGET key1 [key2..]</td><td>获取所有(一个或多个)给定 key 的值。</td></tr><tr><td>SETBIT key offset value</td><td>对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</td></tr><tr><td>SETEX key seconds value</td><td>将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。</td></tr><tr><td>SETNX key value</td><td>只有在 key 不存在时设置 key 的值。</td></tr><tr><td>SETRANGE key offset value</td><td>用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。</td></tr><tr><td>STRLEN key</td><td>返回 key 所储存的字符串值的长度。</td></tr><tr><td>MSET key value [key value …]</td><td>同时设置一个或多个 key-value 对。</td></tr><tr><td>MSETNX key value [key value …]</td><td>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</td></tr><tr><td>PSETEX key milliseconds value</td><td>这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。</td></tr><tr><td>INCR key</td><td>将 key 中储存的数字值增一。</td></tr><tr><td>INCRBY key increment</td><td>将 key 所储存的值加上给定的增量值（increment） 。</td></tr><tr><td>INCRBYFLOAT key increment</td><td>将 key 所储存的值加上给定的浮点增量值（increment） 。</td></tr><tr><td>DECR key</td><td>将 key 中储存的数字值减一。</td></tr><tr><td>DECRBY key decrement</td><td>key 所储存的值减去给定的减量值（decrement） 。</td></tr><tr><td>APPEND key value</td><td>如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。</td></tr></tbody></table><p>案例：</p><pre><code class="hljs awk">set<span class="hljs-regexp">/get/</span>del<span class="hljs-regexp">/append/</span>strlen:设值<span class="hljs-regexp">/获取值/</span>删除键值<span class="hljs-regexp">/追加值/</span>值长度incr<span class="hljs-regexp">/decr/i</span>ncrby<span class="hljs-regexp">/dectby:增1/</span>减<span class="hljs-number">1</span><span class="hljs-regexp">/将 key 所储存的值加上给定的增量值（increment）/</span>将 key 所储存的值减去给定的增量值（increment）(值必须为数字才能进行加减)。getrange/setrange:mset<span class="hljs-regexp">/mget/m</span>setnx:可以多组操作getset：先get在set</code></pre><p><img src="/blogimg/image-20200925103802045.png" alt="image-20200925103802045"></p><h2 id="List：（单值多value）"><a href="#List：（单值多value）" class="headerlink" title="List：（单值多value）"></a>List：（单值多value）</h2><h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>BLPOP key1 [key2 ] timeout</td><td>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td>BRPOP key1 [key2 ] timeout</td><td>移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td>BRPOPLPUSH source destination timeout</td><td>从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td>LINDEX key index</td><td>通过索引获取列表中的元素</td></tr><tr><td>LINSERT key BEFORE/AFTER pivot value</td><td>在列表的元素前或者后插入元素</td></tr><tr><td>LLEN key</td><td>获取列表长度</td></tr><tr><td>LPOP key</td><td>移出并获取列表的第一个元素</td></tr><tr><td>LPUSH key value1 [value2]</td><td>将一个或多个值插入到列表头部</td></tr><tr><td>LPUSHX key value</td><td>将一个值插入到已存在的列表头部</td></tr><tr><td>LRANGE key start stop</td><td>获取列表指定范围内的元素</td></tr><tr><td>LREM key count value</td><td>移除列表元素</td></tr><tr><td>LSET key index value</td><td>通过索引设置列表元素的值</td></tr><tr><td>LTRIM key start stop</td><td>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</td></tr><tr><td>RPOP key</td><td>移除列表的最后一个元素，返回值为移除的元素。</td></tr><tr><td>RPOPLPUSH source destination</td><td>移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td></tr><tr><td>RPUSH key value1 [value2]</td><td>在列表中添加一个或多个值</td></tr><tr><td>RPUSHX key value</td><td>为已存在的列表添加值</td></tr></tbody></table><pre><code class="hljs tcl">lpush/rpush/<span class="hljs-keyword">lrange</span>:入/出lpop/rpop:出并移除<span class="hljs-keyword">lindex</span>:按照索引下表或得元素llen key:获取长度lrem key：删n个valueltrim key 开始index 结束index：截取指定范围的值后再赋值给keyrpoplpush 源列表 目的列表:底出顶进<span class="hljs-keyword">linsert</span> key before/<span class="hljs-keyword">after</span> 值<span class="hljs-number">1</span> 值<span class="hljs-number">2</span>:值<span class="hljs-number">1</span>问列表中有的值，在这个值之前之后插入</code></pre><p><img src="/blogimg/image-20200925110729421.png" alt="image-20200925110729421"></p><p><img src="/blogimg/image-20200925110759998.png" alt="image-20200925110759998"></p><p><img src="/blogimg/image-20200925114352958.png" alt="image-20200925114352958"></p><p>性能总结：</p><ul><li>它是一个字符串链表，left、right都可以插入添加；</li><li>如果键不存在，创建新的链表；</li><li>如果键已存在，新增内容；</li><li>如果值全移除，对应的键也就消失了。</li><li>链表的操作无论是头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡了。</li></ul><h2 id="Set-单值多value-（不会有重复数据）"><a href="#Set-单值多value-（不会有重复数据）" class="headerlink" title="Set:(单值多value)（不会有重复数据）"></a>Set:(单值多value)（不会有重复数据）</h2><h3 id="常用-1"><a href="#常用-1" class="headerlink" title="常用"></a>常用</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>SADD key member1 [member2]</td><td>向集合添加一个或多个成员</td></tr><tr><td>SCARD key</td><td>获取集合的成员数</td></tr><tr><td>SDIFF key1 [key2]</td><td>返回给定所有集合的差集</td></tr><tr><td>SDIFFSTORE destination key1 [key2]</td><td>返回给定所有集合的差集并存储在 destination 中</td></tr><tr><td>SINTER key1 [key2]</td><td>返回给定所有集合的交集</td></tr><tr><td>SINTERSTORE destination key1 [key2]</td><td>返回给定所有集合的交集并存储在 destination 中</td></tr><tr><td>SISMEMBER key member</td><td>判断 member 元素是否是集合 key 的成员</td></tr><tr><td>SMEMBERS key</td><td>返回集合中的所有成员</td></tr><tr><td>SMOVE source destination member</td><td>将 member 元素从 source 集合移动到 destination 集合</td></tr><tr><td>SPOP key</td><td>移除并返回集合中的一个随机元素</td></tr><tr><td>SRANDMEMBER key [count]</td><td>返回集合中一个或多个随机数</td></tr><tr><td>SREM key member1 [member2]</td><td>移除集合中一个或多个成员</td></tr><tr><td>SUNION key1 [key2]</td><td>返回所有给定集合的并集</td></tr><tr><td>SUNIONSTORE destination key1 [key2]</td><td>所有给定集合的并集存储在 destination 集合中</td></tr><tr><td>SSCAN key cursor [MATCH pattern] [COUNT count]</td><td>迭代集合中的元素</td></tr></tbody></table><p><img src="/blogimg/image-20200925133415606.png" alt="image-20200925133415606"></p><p><img src="/blogimg/image-20200925133448672.png" alt="image-20200925133448672"></p><h2 id="Hash-哈希-：（KV模式，但V是一个键值对）"><a href="#Hash-哈希-：（KV模式，但V是一个键值对）" class="headerlink" title="Hash(哈希)：（KV模式，但V是一个键值对）"></a>Hash(哈希)：（KV模式，但V是一个键值对）</h2><h3 id="常用-2"><a href="#常用-2" class="headerlink" title="常用"></a>常用</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>HDEL key field1 [field2]</td><td>删除一个或多个哈希表字段</td></tr><tr><td>HEXISTS key field</td><td>查看哈希表 key 中，指定的字段是否存在。</td></tr><tr><td>HGET key field</td><td>获取存储在哈希表中指定字段的值。</td></tr><tr><td>HGETALL key</td><td>获取在哈希表中指定 key 的所有字段和值</td></tr><tr><td>HINCRBY key field increment</td><td>为哈希表 key 中的指定字段的整数值加上增量 increment 。</td></tr><tr><td>HINCRBYFLOAT key field increment</td><td>为哈希表 key 中的指定字段的浮点数值加上增量 increment 。</td></tr><tr><td>HKEYS key</td><td>获取所有哈希表中的字段</td></tr><tr><td>HLEN key</td><td>获取哈希表中字段的数量</td></tr><tr><td>HMGET key field1 [field2]</td><td>获取所有给定字段的值</td></tr><tr><td>HMSET key field1 value1 [field2 value2 ]</td><td>同时将多个 field-value (域-值)对设置到哈希表 key 中。</td></tr><tr><td>HSET key field value</td><td>将哈希表 key 中的字段 field 的值设为 value 。</td></tr><tr><td>HSETNX key field value</td><td>只有在字段 field 不存在时，设置哈希表字段的值。</td></tr><tr><td>HVALS key</td><td>获取哈希表中所有值。</td></tr><tr><td>HSCAN key cursor [MATCH pattern] [COUNT count]</td><td>迭代哈希表中的键值对。</td></tr></tbody></table><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>hset/hget/hmset/hmget/hgetall/hdel<span class="hljs-bullet">- </span>hlen<span class="hljs-bullet">- </span>hexists key 在key里面的某个值的key<span class="hljs-bullet">- </span>hkeys/hvals<span class="hljs-bullet">- </span>hincrby/hincrbyfloat<span class="hljs-bullet">- </span>hsetnx</code></pre><p><img src="/blogimg/image-20200925134712063.png" alt="image-20200925134712063"></p><h2 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h2><p>在set基础上，加一个score值。之前set是k1 v1 v2 v3，现在zset是k1 score1 v1 score2 v2</p><h3 id="常用-3"><a href="#常用-3" class="headerlink" title="常用"></a>常用</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>ZADD key score1 member1 [score2 member2]</td><td>向有序集合添加一个或多个成员，或者更新已存在成员的分数</td></tr><tr><td>ZCARD key</td><td>获取有序集合的成员数</td></tr><tr><td>ZCOUNT key min max</td><td>计算在有序集合中指定区间分数的成员数</td></tr><tr><td>ZINCRBY key increment member</td><td>有序集合中对指定成员的分数加上增量 increment</td></tr><tr><td>ZINTERSTORE destination numkeys key [key …]</td><td>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</td></tr><tr><td>ZLEXCOUNT key min max</td><td>在有序集合中计算指定字典区间内成员数量</td></tr><tr><td>ZRANGE key start stop [WITHSCORES]</td><td>通过索引区间返回有序集合指定区间内的成员</td></tr><tr><td>ZRANGEBYLEX key min max [LIMIT offset count]</td><td>通过字典区间返回有序集合的成员</td></tr><tr><td>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]</td><td>通过分数返回有序集合指定区间内的成员</td></tr><tr><td>ZRANK key member</td><td>返回有序集合中指定成员的索引</td></tr><tr><td>ZREM key member [member …]</td><td>移除有序集合中的一个或多个成员</td></tr><tr><td>ZREMRANGEBYLEX key min max</td><td>移除有序集合中给定的字典区间的所有成员</td></tr><tr><td>ZREMRANGEBYRANK key start stop</td><td>移除有序集合中给定的排名区间的所有成员</td></tr><tr><td>ZREMRANGEBYSCORE key min max</td><td>移除有序集合中给定的分数区间的所有成员</td></tr><tr><td>ZREVRANGE key start stop [WITHSCORES]</td><td>返回有序集中指定区间内的成员，通过索引，分数从高到低</td></tr><tr><td>ZREVRANGEBYSCORE key max min [WITHSCORES]</td><td>返回有序集中指定分数区间内的成员，分数从高到低排序</td></tr><tr><td>ZREVRANK key member</td><td>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td></tr><tr><td>ZSCORE key member</td><td>返回有序集中，成员的分数值</td></tr><tr><td>ZUNIONSTORE destination numkeys key [key …]</td><td>计算给定的一个或多个有序集的并集，并存储在新的 key 中</td></tr><tr><td>ZSCAN key cursor [MATCH pattern] [COUNT count]</td><td>迭代有序集合中的元素（包括元素成员和元素分值）</td></tr></tbody></table><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><p>*<strong><strong><strong><strong>**</strong></strong></strong></strong>@@@@@@@@</p><h2 id="配置文件介绍"><a href="#配置文件介绍" class="headerlink" title="配置文件介绍"></a>配置文件介绍</h2><p>redis的配置文件位于redis的安装目录下，文件名为redis.conf。可以通过config命令查看或设置配置项。</p><p>实例：</p><pre><code class="hljs routeros">redis 127.0.0.1:6379&gt;<span class="hljs-built_in"> CONFIG </span><span class="hljs-builtin-name">GET</span> loglevel1) <span class="hljs-string">&quot;loglevel&quot;</span>2) <span class="hljs-string">&quot;notice&quot;</span></code></pre><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><p>redis。conf配置项说明如下：（不全）</p><table><thead><tr><th>序号</th><th>配置项</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td><code>daemonize no</code></td><td>Redis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程（Windows 不支持守护线程的配置为 no ）</td></tr><tr><td>2</td><td><code>pidfile /var/run/redis.pid</code></td><td>当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入 /var/run/redis.pid 文件，可以通过 pidfile 指定</td></tr><tr><td>3</td><td><code>port 6379</code></td><td>指定 Redis 监听端口，默认端口为 6379，作者在自己的一篇博文中解释了为什么选用 6379 作为默认端口，因为 6379 在手机按键上 MERZ 对应的号码，而 MERZ 取自意大利歌女 Alessia Merz 的名字</td></tr><tr><td>4</td><td><code>bind 127.0.0.1</code></td><td>绑定的主机地址</td></tr><tr><td>5</td><td><code>timeout 300</code></td><td>当客户端闲置多长秒后关闭连接，如果指定为 0 ，表示关闭该功能</td></tr><tr><td>6</td><td><code>loglevel notice</code></td><td>指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice</td></tr><tr><td>7</td><td><code>logfile stdout</code></td><td>日志记录方式，默认为标准输出，如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 /dev/null</td></tr><tr><td>8</td><td><code>databases 16</code></td><td>设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id</td></tr><tr><td>9</td><td><code>save &lt;seconds&gt; &lt;changes&gt;</code><br>Redis 默认配置文件中提供了三个条件：<br><code>save 900 1</code><br><code>save 300 10</code><br><code>save 60 10000</code><br></td><td>分别表示 900 秒（15 分钟）内有 1 个更改，300 秒（5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。<br>指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</td></tr><tr><td>10</td><td><code>rdbcompression yes</code></td><td>指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大</td></tr><tr><td>11</td><td><code>dbfilename dump.rdb</code></td><td>指定本地数据库文件名，默认值为 dump.rdb</td></tr><tr><td>12</td><td><code>dir ./</code></td><td>指定本地数据库存放目录</td></tr><tr><td>13</td><td><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></td><td>设置当本机为 slave 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步</td></tr><tr><td>14</td><td><code>masterauth &lt;master-password&gt;</code></td><td>当 master 服务设置了密码保护时，slav 服务连接 master 的密码</td></tr><tr><td>15</td><td><code>requirepass foobared</code></td><td>设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 AUTH <password> 命令提供密码，默认关闭</td></tr><tr><td>16</td><td><code>maxclients 128</code></td><td>设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息</td></tr><tr><td>17</td><td><code>maxmemory &lt;bytes&gt;</code></td><td>指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区</td></tr><tr><td>18</td><td><code>appendonly no</code></td><td>指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no</td></tr><tr><td>19</td><td><code>appendfilename appendonly.aof</code></td><td>指定更新日志文件名，默认为 appendonly.aof</td></tr><tr><td>20</td><td><code>appendfsync everysec</code></td><td>指定更新日志条件，共有 3 个可选值：<br>no：表示等操作系统进行数据缓存同步到磁盘（快）<br>always：表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）<br>everysec：表示每秒同步一次（折中，默认值）<br></td></tr><tr><td>21</td><td><code>vm-enabled no</code></td><td>指定是否启用虚拟内存机制，默认值为 no，简单的介绍一下，VM 机制将数据分页存放，由 Redis 将浏览量较少的页即冷数据 swap 到磁盘上，浏览多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析 Redis 的 VM 机制）</td></tr><tr><td>22</td><td><code>vm-swap-file /tmp/redis.swap</code></td><td>虚拟内存文件路径，默认值为 /tmp/redis.swap，不可多个 Redis 实例共享</td></tr><tr><td>23</td><td><code>vm-max-memory 0</code></td><td>将所有大于 vm-max-memory 的数据存入虚拟内存，无论 vm-max-memory 设置多小，所有索引数据都是内存存储的(Redis 的索引数据 就是 keys)，也就是说，当 vm-max-memory 设置为 0 的时候，其实是所有 value 都存在于磁盘。默认值为 0</td></tr><tr><td>24</td><td><code>vm-page-size 32</code></td><td>Redis swap 文件分成了很多的 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，vm-page-size 是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page 大小最好设置为 32 或者 64bytes；如果存储很大大对象，则可以使用更大的 page，如果不确定，就使用默认值</td></tr><tr><td>25</td><td><code>vm-pages 134217728</code></td><td>设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是在放在内存中的，，在磁盘上每 8 个 pages 将消耗 1byte 的内存。</td></tr><tr><td>26</td><td><code>vm-max-threads 4</code></td><td>设置连接swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</td></tr><tr><td>27</td><td><code>glueoutputbuf yes</code></td><td>设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</td></tr><tr><td>28</td><td><code>hash-max-zipmap-entries 64</code><br><code>hash-max-zipmap-value 512</code></td><td>指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</td></tr><tr><td>29</td><td><code>activerehashing yes</code></td><td>指定是否激活重置哈希，默认为开启（后面在介绍 Redis 的哈希算法时具体介绍）</td></tr><tr><td>30</td><td><code>include /path/to/local.conf</code></td><td>指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</td></tr></tbody></table><h2 id="持久化值RDB"><a href="#持久化值RDB" class="headerlink" title="持久化值RDB"></a>持久化值RDB</h2><h3 id="RDB是什么："><a href="#RDB是什么：" class="headerlink" title="RDB是什么："></a>RDB是什么：</h3><ul><li>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里</li><li>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</li></ul><pre><code class="hljs">ForkFork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</code></pre><ul><li>rdb 保存的是dump.rdb文件</li><li>相关配置在配置文件的位置 - 在redis.conf搜寻<code>### SNAPSHOTTING ###</code></li></ul><h3 id="如何触发RDB快照"><a href="#如何触发RDB快照" class="headerlink" title="如何触发RDB快照"></a>如何触发RDB快照</h3><ul><li><p>配置文件中默认的快照配置</p><pre><code class="hljs css"><span class="hljs-selector-tag">dbfilename</span> <span class="hljs-selector-tag">dump</span><span class="hljs-selector-class">.rdb</span></code></pre><ul><li>冷拷贝后重新使用<ul><li>可以cp dump.rdb dump_new.rdb</li></ul></li></ul></li><li><p>命令save或者是bgsave</p><ul><li>Save：save时只管保存，其它不管，全部阻塞</li><li>BGSAVE：Redis会在后台异步进行快照操作， 快照同时还可以响应客户端请求。可以通过lastsave 命令获取最后一次成功执行快照的时间</li></ul></li><li><p>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</p></li></ul><h3 id="如何恢复"><a href="#如何恢复" class="headerlink" title="如何恢复"></a>如何恢复</h3><ul><li>将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可</li><li><code>CONFIG GET dir</code>获取目录</li></ul><h3 id="优势与劣势"><a href="#优势与劣势" class="headerlink" title="优势与劣势"></a>优势与劣势</h3><ul><li>优势<ul><li>适合大规模的数据恢复</li><li>对数据完整性和一致性要求不高</li></ul></li><li>劣势<ul><li>在一定间隔时间做一次备份，所以如果redis意外down掉的话，就 会丢失最后一次快照后的所有修改</li><li>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li></ul></li></ul><h3 id="如何停止"><a href="#如何停止" class="headerlink" title="如何停止"></a>如何停止</h3><p>动态所有停止RDB保存规则的方法：<code>redis-cli config set save &quot;&quot;</code></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="https://gitee.com/jallenkwong/LearnRedis/raw/master/image/21.png" alt="img"></p><ul><li>RDB是一个非常紧凑的文件。</li><li>RDB在保存RDB文件时父进程唯一需要做的就是fork出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他I0操作，所以RDB持久化方式可以最大化redis的性能。</li><li>与AOF相比，在恢复大的数据集的时候，RDB方式会更快一一些。</li><li>数据丢失风险大。</li><li>RDB需要经常fork子进程来保存数据集到硬盘上，当数据集比较大的时候fork的过程是非常耗时的吗，可能会导致Redis在一些毫秒级不能回应客户端请求。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis五大数据类型：&quot;&gt;&lt;a href=&quot;#Redis五大数据类型：&quot; class=&quot;headerlink&quot; title=&quot;Redis五大数据类型：&quot;&gt;&lt;/a&gt;Redis五大数据类型：&lt;/h1&gt;&lt;p&gt;String（字符串）、Hash（哈希，类似java中的Ma</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>NoSQL介绍</title>
    <link href="http://example.com/2020/09/21/Redis/NoSQL/"/>
    <id>http://example.com/2020/09/21/Redis/NoSQL/</id>
    <published>2020-09-21T14:14:05.820Z</published>
    <updated>2020-09-25T06:14:09.590Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL:"></a>NoSQL:</h1><p>数据类型：聚合模型</p><h1 id="MongoDB："><a href="#MongoDB：" class="headerlink" title="MongoDB："></a>MongoDB：</h1><p>基于分布式文件存储的数据库。介于关系型数据库和非关系型数据库之间的产品。</p><h1 id="NoSQL数据库的四大类："><a href="#NoSQL数据库的四大类：" class="headerlink" title="NoSQL数据库的四大类："></a>NoSQL数据库的四大类：</h1><p>KV键值、文件型数据库（BSON格式较多）、列存储数据库、图关系数据库。四者比对如下：</p><p><img src="/blogimg/image-20200921222249034.png" alt="image-20200921222249034"></p><h1 id="在分布式数据库中CAP原理CAP-BASE："><a href="#在分布式数据库中CAP原理CAP-BASE：" class="headerlink" title="在分布式数据库中CAP原理CAP+BASE："></a>在分布式数据库中CAP原理CAP+BASE：</h1><h2 id="传统的ACID分别是什么：（关系型数据库）"><a href="#传统的ACID分别是什么：（关系型数据库）" class="headerlink" title="传统的ACID分别是什么：（关系型数据库）"></a>传统的ACID分别是什么：（关系型数据库）</h2><p>A(Atomicity)原子性</p><p>C(Consistency)一致性</p><p>I(Isolation)独立性</p><p>D(Durability)持久性</p><p><img src="/blogimg/image-20200921223104548.png" alt="image-20200921223104548"></p><h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP:"></a>CAP:</h2><p>C:Consisteny(强一致性)</p><p>A:Availability(可用性)</p><p>P:Partition tolerance(分区容错性)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NoSQL&quot;&gt;&lt;a href=&quot;#NoSQL&quot; class=&quot;headerlink&quot; title=&quot;NoSQL:&quot;&gt;&lt;/a&gt;NoSQL:&lt;/h1&gt;&lt;p&gt;数据类型：聚合模型&lt;/p&gt;
&lt;h1 id=&quot;MongoDB：&quot;&gt;&lt;a href=&quot;#MongoDB：&quot; clas</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>控制流</title>
    <link href="http://example.com/2020/09/09/On%20Java8/%E6%8E%A7%E5%88%B6%E6%B5%81/"/>
    <id>http://example.com/2020/09/09/On%20Java8/%E6%8E%A7%E5%88%B6%E6%B5%81/</id>
    <published>2020-09-09T06:10:32.327Z</published>
    <updated>2020-09-25T06:00:45.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Break和continue关键字用法："><a href="#Break和continue关键字用法：" class="headerlink" title="Break和continue关键字用法："></a>Break和continue关键字用法：</h1><ol><li>简单的一个continue会退回最内层循环的开头（顶部），并继续执行。</li><li>带有标签的continue会到达标签的位置，并重新进入紧接在那个标签后面的循环。</li><li>break会中断当前循环，并移离当前标签的末尾。</li><li>带标签的break会中断当前循环，并移离由那个标签指示的循环末尾。</li></ol><h1 id="this关键字："><a href="#this关键字：" class="headerlink" title="this关键字："></a>this关键字：</h1><p>表示当前对象。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leaf</span> </span>&#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-function">Leaf <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;        i++;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;i = &quot;</span> + i);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Leaf x = <span class="hljs-keyword">new</span> Leaf();        x.increment().increment().increment().print();    &#125;&#125;</code></pre><p>输出：</p><pre><code class="hljs java">i=<span class="hljs-number">3</span></code></pre><h1 id="垃圾回收器如何工作？"><a href="#垃圾回收器如何工作？" class="headerlink" title="垃圾回收器如何工作？"></a>垃圾回收器如何工作？</h1><p>“自适应的、分代的、停止-复制、标记-清扫”式的垃圾回收器。</p><h1 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h1><p>在类中只初始化一次。</p><h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><p>被final修饰的属性不能被修改，修饰的类不能被继承。</p><h1 id="多态："><a href="#多态：" class="headerlink" title="多态："></a>多态：</h1><p>多态提供了另一个维度的接口与实现分离，以解耦做什么和怎么做。多态不仅能改善代码的组织，提高代码的可读性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Break和continue关键字用法：&quot;&gt;&lt;a href=&quot;#Break和continue关键字用法：&quot; class=&quot;headerlink&quot; title=&quot;Break和continue关键字用法：&quot;&gt;&lt;/a&gt;Break和continue关键字用法：&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="On Java8" scheme="http://example.com/categories/On-Java8/"/>
    
    
    <category term="On Java" scheme="http://example.com/tags/On-Java/"/>
    
  </entry>
  
  <entry>
    <title>CAS</title>
    <link href="http://example.com/2020/09/03/%E9%AB%98%E5%B9%B6%E5%8F%91/CAS/"/>
    <id>http://example.com/2020/09/03/%E9%AB%98%E5%B9%B6%E5%8F%91/CAS/</id>
    <published>2020-09-03T14:25:18.201Z</published>
    <updated>2020-09-25T06:19:19.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CAS："><a href="#CAS：" class="headerlink" title="CAS："></a>CAS：</h1><p>Compare and swap/compare and exchange 比较并且交换</p><p>ABA问题解决：加标签或者版本号</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CAS：&quot;&gt;&lt;a href=&quot;#CAS：&quot; class=&quot;headerlink&quot; title=&quot;CAS：&quot;&gt;&lt;/a&gt;CAS：&lt;/h1&gt;&lt;p&gt;Compare and swap/compare and exchange 比较并且交换&lt;/p&gt;
&lt;p&gt;ABA问题解决：加标</summary>
      
    
    
    
    <category term="高并发" scheme="http://example.com/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="高并发" scheme="http://example.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Kafak环境搭建</title>
    <link href="http://example.com/2020/09/01/kafka/1.%E6%90%AD%E5%BB%BA/"/>
    <id>http://example.com/2020/09/01/kafka/1.%E6%90%AD%E5%BB%BA/</id>
    <published>2020-09-01T09:24:44.078Z</published>
    <updated>2020-09-25T06:18:56.583Z</updated>
    
    <content type="html"><![CDATA[<p>jdk：<a href="https://www.cnblogs.com/songxingzhu/p/9254749.html">https://www.cnblogs.com/songxingzhu/p/9254749.html</a></p><p>kafka：<a href="https://developer.aliyun.com/article/708277">https://developer.aliyun.com/article/708277</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;jdk：&lt;a href=&quot;https://www.cnblogs.com/songxingzhu/p/9254749.html&quot;&gt;https://www.cnblogs.com/songxingzhu/p/9254749.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;kafka：&lt;a h</summary>
      
    
    
    
    <category term="Kafak" scheme="http://example.com/categories/Kafak/"/>
    
    
    <category term="Kafak" scheme="http://example.com/tags/Kafak/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB创建数据库</title>
    <link href="http://example.com/2020/09/01/MongoDB/1.%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://example.com/2020/09/01/MongoDB/1.%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2020-09-01T08:15:16.769Z</published>
    <updated>2020-09-25T06:19:04.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MongoDB连接："><a href="#MongoDB连接：" class="headerlink" title="MongoDB连接："></a>MongoDB连接：</h1><p>执行mongo</p><h1 id="MongoDB创建数据库："><a href="#MongoDB创建数据库：" class="headerlink" title="MongoDB创建数据库："></a>MongoDB创建数据库：</h1><pre><code class="hljs sql"><span class="hljs-keyword">use</span> database_name</code></pre><p>查看数据库：</p><pre><code class="hljs sql"><span class="hljs-keyword">show</span> dbs</code></pre><p>新创建的数据库刚开始会看不到，必须向数据库插入一条数据。</p><pre><code class="hljs sql">db.database_name.insert(&#123;&quot;name&quot;:&quot;XXX&quot;&#125;)</code></pre><p>在执行show dbs,就会看到新建的数据库。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MongoDB连接：&quot;&gt;&lt;a href=&quot;#MongoDB连接：&quot; class=&quot;headerlink&quot; title=&quot;MongoDB连接：&quot;&gt;&lt;/a&gt;MongoDB连接：&lt;/h1&gt;&lt;p&gt;执行mongo&lt;/p&gt;
&lt;h1 id=&quot;MongoDB创建数据库：&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="MongoDB" scheme="http://example.com/categories/MongoDB/"/>
    
    
    <category term="MongoDB" scheme="http://example.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>第一章 对象的概念</title>
    <link href="http://example.com/2020/08/31/On%20Java8/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    <id>http://example.com/2020/08/31/On%20Java8/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5/</id>
    <published>2020-08-31T06:42:59.338Z</published>
    <updated>2020-09-25T06:14:03.138Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象编程是一种编程思维方式和编码架构。</p><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>List：常用于保存序列；</p><p>Map：常用于将对象与其他对象关联；</p><p>Set：只能保存非重复的值；</p><p>其他包括队列（Queue）、树（Tree）、栈（Stack）、堆（Heap）等等。</p><h2 id="ArrayList和LinkedList区别："><a href="#ArrayList和LinkedList区别：" class="headerlink" title="ArrayList和LinkedList区别："></a>ArrayList和LinkedList区别：</h2><p>两者具有相同接口和外部行为，但是在某些操作中它们的效率差别很大。在ArrayList中随机查找元素是很高效的，而LinkedList随机查找效率低下。反之，在LinkedList中插入元素的效率要比在ArrayList中高。由于底层数据结构的不同，每种集合类型在执行相同的操作时会表现出效率上的差异。</p><h2 id="面向对象编程的一个优点是："><a href="#面向对象编程的一个优点是：" class="headerlink" title="面向对象编程的一个优点是："></a>面向对象编程的一个优点是：</h2><p>设计良好的java程序代码更容易被人阅读理解。由于java类库的复用性，通常程序要写的代码也会少的多。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;面向对象编程是一种编程思维方式和编码架构。&lt;/p&gt;
&lt;h1 id=&quot;集合&quot;&gt;&lt;a href=&quot;#集合&quot; class=&quot;headerlink&quot; title=&quot;集合&quot;&gt;&lt;/a&gt;集合&lt;/h1&gt;&lt;p&gt;List：常用于保存序列；&lt;/p&gt;
&lt;p&gt;Map：常用于将对象与其他对象关联；&lt;/</summary>
      
    
    
    
    <category term="On Java8" scheme="http://example.com/categories/On-Java8/"/>
    
    
    <category term="On Java" scheme="http://example.com/tags/On-Java/"/>
    
  </entry>
  
  <entry>
    <title>递归</title>
    <link href="http://example.com/2020/08/27/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/"/>
    <id>http://example.com/2020/08/27/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/</id>
    <published>2020-08-27T02:14:32.314Z</published>
    <updated>2020-09-08T07:02:12.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、编写递归代码最重要的三点："><a href="#1、编写递归代码最重要的三点：" class="headerlink" title="1、编写递归代码最重要的三点："></a>1、编写递归代码最重要的三点：</h1><ul><li>递归总有一个最简单的情况–方法的第一条语句总是包含return的条件语句。</li><li>递归调用总是尝试解决一个规模更小的子问题，这样递归才能收敛到最简单的情况。</li><li>递归调用的父类问题和尝试解决的子问题之间不应该有交集。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1、编写递归代码最重要的三点：&quot;&gt;&lt;a href=&quot;#1、编写递归代码最重要的三点：&quot; class=&quot;headerlink&quot; title=&quot;1、编写递归代码最重要的三点：&quot;&gt;&lt;/a&gt;1、编写递归代码最重要的三点：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;递归总有一个最简单的情况</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>时间复杂度</title>
    <link href="http://example.com/2020/07/29/%E7%AE%97%E6%B3%95/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>http://example.com/2020/07/29/%E7%AE%97%E6%B3%95/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</id>
    <published>2020-07-29T14:04:37.723Z</published>
    <updated>2020-09-08T07:02:29.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法的时间和空间复杂度："><a href="#算法的时间和空间复杂度：" class="headerlink" title="算法的时间和空间复杂度："></a>算法的时间和空间复杂度：</h1><p>时间复杂度和空间复杂度是用来衡量算法的快慢的。</p><p>引：<a href="https://zhuanlan.zhihu.com/p/50479555">https://zhuanlan.zhihu.com/p/50479555</a></p><p>时间复杂度：看循环</p><p>空间复杂度：看分配空间，比如new对象</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法的时间和空间复杂度：&quot;&gt;&lt;a href=&quot;#算法的时间和空间复杂度：&quot; class=&quot;headerlink&quot; title=&quot;算法的时间和空间复杂度：&quot;&gt;&lt;/a&gt;算法的时间和空间复杂度：&lt;/h1&gt;&lt;p&gt;时间复杂度和空间复杂度是用来衡量算法的快慢的。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>6.配置中心Spring Cloud Config初体验</title>
    <link href="http://example.com/2020/04/30/SpringCloud/6.%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83Spring%20Cloud%20Config%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://example.com/2020/04/30/SpringCloud/6.%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83Spring%20Cloud%20Config%E5%88%9D%E4%BD%93%E9%AA%8C/</id>
    <published>2020-04-30T08:13:14.780Z</published>
    <updated>2020-09-08T07:26:12.041Z</updated>
    
    
    
    
    <category term="SpringCloud" scheme="http://example.com/categories/SpringCloud/"/>
    
    
    <category term="SpringCloud" scheme="http://example.com/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>5.熔断器Hystrix的使用+可视化监控Dashboard和Turbine</title>
    <link href="http://example.com/2020/04/30/SpringCloud/5.%E7%86%94%E6%96%AD%E5%99%A8Hystrix%E7%9A%84%E4%BD%BF%E7%94%A8+%20%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9B%91%E6%8E%A7Dashboard%E5%92%8CTurbine/"/>
    <id>http://example.com/2020/04/30/SpringCloud/5.%E7%86%94%E6%96%AD%E5%99%A8Hystrix%E7%9A%84%E4%BD%BF%E7%94%A8+%20%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9B%91%E6%8E%A7Dashboard%E5%92%8CTurbine/</id>
    <published>2020-04-30T01:56:30.760Z</published>
    <updated>2020-09-08T07:34:06.347Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是Hystrix之熔断和降级"><a href="#什么是Hystrix之熔断和降级" class="headerlink" title="什么是Hystrix之熔断和降级"></a>什么是Hystrix之熔断和降级</h1><p>官方:在分布式环境中，不可避免地会有许多服务依赖项中的某些失败。Hystrix是一个库，可通过添加等待时间容限和容错逻辑来帮助你控制这些分布式服务之间的交互。Hystrix通过隔离服务之间的访问点，停止服务之间的级联故障并提供后备选项实现此目的，所有这些都可以提高系统的整体弹性。</p><p>总体来说[Hystrix]就是一个能进行熔断和降级的库，通过使用它能提高整个系统的弹性。</p><h1 id="什么是熔断和降级"><a href="#什么是熔断和降级" class="headerlink" title="什么是熔断和降级"></a>什么是熔断和降级</h1><p>举个例子，此时我们整个微服务系统是这样的。服务A调用了服务B，服务B在调用了服务C，但是因为某些原因，服务C顶不住了，这个时候大量请求会在服务C阻塞。</p><p><img src="/blogimg/640-20200430100748935.jpeg" alt="img"></p><p>服务C阻塞了还好，毕竟只是一个系统崩溃了。但是请注意这个时候因为服务C不能返回响应，那么服务B调用服务C的请求就会阻塞，同理服务B阻塞了，那么服务A夜壶一阻塞崩溃。</p><p>***  请注意，为什么阻塞会崩溃。因为这些请求会消耗占用系统的线程、IO等资源，消耗完系统服务器就崩了。</p><p><img src="/blogimg/640-20200430101129919.jpeg" alt="img"></p><p>这就叫服务雪崩。</p><p>所谓熔断就是服务雪崩的一种有效解决方案。当指定时间窗内的请求失败率达到设定阈值时，系统将通过断路器直接将此请求链路断开。</p><p>也就是我们上面服务B调用服务C在指定时间窗内，调用的失败率到达了一定的值，那么[Hystrix]则会自动讲服务B与C之间的请求都断了，以免导致服务雪崩现象。</p><p>其实这里所讲的熔断就是指的[Hystrix]中的断路器模式，</p><p>降级是为了更好的用户体验，当一个方法调用异常时，通过执行另一种代码逻辑来给用户友好的回复。这也就是对应着[Hystrix]后备处理模式。可以通过设置fallbackMethod来给一个方法设置备用的代码逻辑。比如这个时候有一个热点新闻出现了，我们会推荐给用户查看详情，然后用户会通过id去查看新闻的详情，但是因为这条新闻太火了，大量用户同时访问可能会导致系统崩溃，那么我么就进行服务降级，一些请求会做一些降级处理比如当前人数太多请稍后查看等等。</p><pre><code class="hljs less"><span class="hljs-comment">// 指定了后备方法调用</span><span class="hljs-variable">@HystrixCommand</span>(fallbackMethod = <span class="hljs-string">&quot;getHystrixNews&quot;</span>)<span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/get/news&quot;</span>)public News getNews(<span class="hljs-variable">@PathVariable</span>(<span class="hljs-string">&quot;id&quot;</span>) int id) &#123; <span class="hljs-comment">// 调用新闻系统的获取新闻api 代码逻辑省略*</span>&#125;<span class="hljs-comment">//</span>public News getHystrixNews(<span class="hljs-variable">@PathVariable</span>(<span class="hljs-string">&quot;id&quot;</span>) int id) &#123;  <span class="hljs-comment">// 做服务降级</span>  <span class="hljs-comment">// 返回当前人数太多，请稍后查看</span>&#125;</code></pre><h1 id="使用Feign-Hystrix"><a href="#使用Feign-Hystrix" class="headerlink" title="使用Feign Hystrix"></a>使用Feign Hystrix</h1><p>依然使用子模块：service-feign</p><p>pom文件不需要变化，因为spring-cloud-starter-openfeign已经自带了Hystrix。</p><p>修改配置文件application.yml,增加如下：</p><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span> <span class="hljs-attr">hystrix:</span>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><span class="hljs-comment"># 熔断器DashBoard: actuator在boot2.0调整后开关web端点的配置，*代表开启所有</span><span class="hljs-attr">management:</span>  <span class="hljs-attr">endpoints:</span>    <span class="hljs-attr">web:</span>      <span class="hljs-attr">exposure:</span>        <span class="hljs-attr">include:</span> <span class="hljs-string">&quot;*&quot;</span></code></pre><p>接着新建类ServiceHiHystrix继承ServiceHi接口，里面实现了失败下的返回信息：</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceHiHystrix</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServiceHi</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHiFromServiceHi</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + name + <span class="hljs-string">&quot;,this message send failed&quot;</span>;    &#125;&#125;</code></pre><p>更改ServiceHi接口，添加上fallback类为刚才新建的类：</p><pre><code class="hljs reasonml">@<span class="hljs-constructor">FeignClient(<span class="hljs-params">value</span> = <span class="hljs-string">&quot;data-server&quot;</span>,<span class="hljs-params">fallback</span> = ServiceHiHystrix.<span class="hljs-params">class</span>)</span></code></pre><p>启动server-feign，data-server和eureka-server测试。</p><p>打开：<a href="http://localhost:8765/hello/test%E3%80%82">http://localhost:8765/hello/test。</a></p><p><img src="/blogimg/image-20200430111215839.png" alt="image-20200430111215839"></p><p>接着，关掉服务提供者data-server，来模拟服务宕机的情况，重新访问：<a href="http://localhost:8765/hello/test%E3%80%82">http://localhost:8765/hello/test。</a></p><p><img src="/blogimg/image-20200430111259661.png" alt="image-20200430111259661"></p><p>返回了新建的错误信息。</p><h1 id="可视化熔断器监控Hystrix-Dashboard和Turbine"><a href="#可视化熔断器监控Hystrix-Dashboard和Turbine" class="headerlink" title="可视化熔断器监控Hystrix Dashboard和Turbine"></a>可视化熔断器监控Hystrix Dashboard和Turbine</h1><h2 id="Hystrix-Dashboard"><a href="#Hystrix-Dashboard" class="headerlink" title="Hystrix Dashboard"></a>Hystrix Dashboard</h2><p>Hystrix-dashboard是一款针对Hystrix进行实时监控的工具，通过Hystrix Dashboard我们可以在直观地看到各Hystrix Command的请求响应时间，请求成功率等数据。</p><p>在server-feign模块继续修改，上面已经在该模块添加了熔断器。</p><p>首先添加依赖：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-comment">&lt;!--spring boot 1.X：spring-cloud-starter-hystrix--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-comment">&lt;!--spring boot 1.X：spring-cloud-starter-hystrix-dashboard--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>启动类修改：</p><pre><code class="hljs less"><span class="hljs-variable">@EnableHystrixDashboard</span><span class="hljs-variable">@EnableCircuitBreaker</span></code></pre><p>启动工程访问：<a href="http://localhost:8765/hystrix%EF%BC%8C%E5%B0%86%E4%BC%9A%E7%9C%8B%E5%88%B0%E5%A6%82%E4%B8%8B%E7%95%8C%E9%9D%A2%EF%BC%9A">http://localhost:8765/hystrix，将会看到如下界面：</a></p><p><img src="/blogimg/image-20200430112702781.png" alt="image-20200430112702781"></p><p>图中会有一些提示：</p><ul><li>Cluster via Turbine (default cluster): <a href="http://turbine-hostname:port/turbine.stream">http://turbine-hostname:port/turbine.stream</a> </li><li>Cluster via Turbine (custom cluster): <a href="http://turbine-hostname:port/turbine.stream?cluster=[clusterName]">http://turbine-hostname:port/turbine.stream?cluster=[clusterName]</a></li><li>Single Hystrix App: <a href="http://hystrix-app:port/hystrix.stream">http://hystrix-app:port/hystrix.stream</a></li></ul><p>大概意思就是如果查看默认集群使用第一个url，查看指定集群使用第二个url，单个应用的监控使用最后一个，单个应用输入：<a href="http://localhost:8765/actuator/hystrix.stream%EF%BC%8C%E8%BE%93%E5%85%A5%E4%B9%8B%E5%90%8E%E7%82%B9%E5%87%BBmonitor%EF%BC%8C%E8%BF%9B%E5%85%A5%E9%A1%B5%E9%9D%A2%E3%80%82">http://localhost:8765/actuator/hystrix.stream，输入之后点击monitor，进入页面。</a></p><p>如果没有请求会先显示Loading …，访问<a href="http://localhost:9001/hystrix.stream">http://localhost:9001/hystrix.stream</a> 也会不断的显示ping。</p><p><img src="/blogimg/image-20200430113122523.png" alt="image-20200430113122523"></p><p>请求服务<a href="http://localhost:8765/hello/test%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E7%9B%91%E6%8E%A7%E7%9A%84%E6%95%88%E6%9E%9C%E4%BA%86%E3%80%82">http://localhost:8765/hello/test，就可以看到监控的效果了。</a></p><p><img src="/blogimg/image-20200430113400187.png" alt="image-20200430113400187"></p><p><img src="/blogimg/9428.png" alt="img"></p><p>到此单个应用的熔断监控已经完成了。</p><h1 id="Turbine"><a href="#Turbine" class="headerlink" title="Turbine"></a>Turbine</h1><p>只使用Hystrix Dashboard的话，只能看到单个应用内的服务信息，这明显不够，需要一个工具能让我们汇总系统内多个服务的数据并显示到Hystrix Dashboard上，这个工具就是Turbine。</p><p>在复杂的分布式系统中，相同服务的节点经常需要部署上百甚至上千个，很多时候，运维人员希望能够把相同服务的节点状态以一个整体集群的形式展现出来，这样可以更好的把握整个系统的状态。</p><p>注意：***</p><p>为了演示Turbine，在这里重新新建一个子模块，名为hystrix-dashboard-turbine。</p><p>创建新模块作为单独的监控节点模块，是因为演示dashboard的时候是耦合在了server-feign中，而Turbine需要同时监控多个服务消费者，把他耦合在一个消费者里显得不合时宜。</p><p>创建后，pom.xml中引入：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-comment">&lt;!--spring boot 1.X：spring-cloud-starter-hystrix-dashboard--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-netflix-turbine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>启动类中@EnableTurbine和@EnableHystrixDashboard：</p><pre><code class="hljs less"><span class="hljs-variable">@SpringBootApplication</span><span class="hljs-variable">@EnableTurbine</span><span class="hljs-variable">@EnableHystrixDashboard</span>public class HystrixDashboardTurbineApplication &#123;    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">static</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">main</span>(String[] args) &#123;        <span class="hljs-selector-tag">SpringApplication</span><span class="hljs-selector-class">.run</span>(HystrixDashboardTurbineApplication.class, args);    &#125;&#125;</code></pre><p>yml中：</p><pre><code class="hljs less"><span class="hljs-attribute">server</span>:  <span class="hljs-attribute">port</span>: <span class="hljs-number">8767</span><span class="hljs-attribute">spring</span>:  <span class="hljs-attribute">application</span>:    <span class="hljs-attribute">name</span>: hystrix-dashboard-turbine<span class="hljs-attribute">eureka</span>:  <span class="hljs-attribute">client</span>:    <span class="hljs-attribute">service-url</span>:      <span class="hljs-attribute">defaultZone</span>: <span class="hljs-attribute">http</span>:<span class="hljs-comment">//localhost:8761/eureka</span>#熔断器turbine<span class="hljs-attribute">turbine</span>:  <span class="hljs-attribute">aggregator</span>:    <span class="hljs-attribute">cluster-config</span>: default  <span class="hljs-attribute">cluster-name-expression</span>: new String(<span class="hljs-string">&quot;default&quot;</span>)  <span class="hljs-attribute">app-config</span>: service-feign,service-feign-<span class="hljs-number">2</span></code></pre><p>代码重点：***</p><ul><li><p>新模块端口号为：8767</p></li><li><p>turbine.appConfig ：配置Eureka中的serviceId列表，表明监控哪些服务（这里指定为SERVICE-FEIGN, SERVICE-FEIGN-2，稍后说）</p></li><li><p>turbine.aggregator.clusterConfig ：指定聚合哪些集群，多个使用”,”分割，默认为default。可使用http://…/turbine.stream?cluster={clusterConfig之一}访问</p></li><li><p>turbine.clusterNameExpression ：</p></li><li><ul><li>clusterNameExpression指定集群名称，默认表达式appName；此时：turbine.aggregator.clusterConfig需要配置想要监控的应用名称；</li><li>当clusterNameExpression: default时，turbine.aggregator.clusterConfig可以不写，因为默认就是default；</li><li>当clusterNameExpression: metadata[‘cluster’]时，假设想要监控的应用配置了eureka.instance.metadata-map.cluster: ABC，则需要配置，同时turbine.aggregator.clusterConfig: ABC</li></ul></li></ul><p>完成这些步骤后，我们还需要调整下服务提供者，我们需要两个服务提供者同时运行。</p><p> 将8765（service-feign）的服务提供者改为8766，名称改为：service-feign-2，运行起来，别忘了在运行设置中设置允许多个实例运行。修改后的service-feign的yml是：</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span> <span class="hljs-comment"># 服务端口号</span> <span class="hljs-attr">port:</span> <span class="hljs-number">8766</span><span class="hljs-attr">spring:</span> <span class="hljs-attr">application:</span>  <span class="hljs-comment"># 服务名，即serviceId</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">service-feign-2</span><span class="hljs-attr">eureka:</span> <span class="hljs-attr">client:</span>  <span class="hljs-attr">serviceUrl:</span>   <span class="hljs-comment"># 安全认证的服务注册中心地址</span>   <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8761/eureka</span><span class="hljs-comment"># 熔断器设置</span><span class="hljs-attr">feign:</span> <span class="hljs-attr">hystrix:</span>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><span class="hljs-comment"># 熔断器DashBoard: actuator在boot2.0调整后开关web端点的配置，*代表开启所有</span><span class="hljs-attr">management:</span> <span class="hljs-attr">endpoints:</span>  <span class="hljs-attr">web:</span>   <span class="hljs-attr">exposure:</span>    <span class="hljs-attr">include:</span> <span class="hljs-string">&quot;*&quot;</span></code></pre><p>访问：先<a href="http://localhost:8767/turbine.stream%EF%BC%8C%E5%9C%A8%E5%88%86%E5%88%AB%E8%AE%BF%E9%97%AEhttp://localhost:8765/hello/1232312%E3%80%81http://localhost:8766/hello/1232312">http://localhost:8767/turbine.stream，在分别访问http://localhost:8765/hello/1232312、http://localhost:8766/hello/1232312</a></p><p><img src="/blogimg/image-20200430155641667.png" alt="image-20200430155641667"></p><p>进行图形化监控查看，输入：<a href="http://localhost:8767/hystrix">http://localhost:8767/hystrix</a> ，返回酷酷的小熊界面，输入： <a href="http://localhost:8767/turbine.stream">http://localhost:8767/turbine.stream</a> ，然后点击 Monitor Stream ,可以看到出现了监控列表:</p><p><img src="/blogimg/image-20200430155816659.png" alt="image-20200430155816659"></p><p>上面只是一个监控。</p><h2 id="聚合监控列表："><a href="#聚合监控列表：" class="headerlink" title="聚合监控列表："></a>聚合监控列表：</h2><p>监控不同的服务熔断，首先得是不同的rpc调用，也就是消费者的熔断函数要是两个不同的，或者，消费者去调用的是两个不同的服务提供者！这样才会有多个监控表。</p><ul><li>新的消费目标（新的服务提供者）</li><li>或者是一个新的消费熔断器。</li></ul><p>修改server-feign子模块</p><p>1、ServiceHi接口的调用变为sayHiFromServiceHi2，value也指向另一个服务提供者data-server-2（新的消费目标（新的服务提供者））</p><pre><code class="hljs dart"><span class="hljs-meta">@FeignClient</span>(value = <span class="hljs-string">&quot;data-server-2&quot;</span>, fallback = ServiceHiHystrix.<span class="hljs-keyword">class</span>)public <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ServiceHi</span> </span>&#123;  <span class="hljs-comment"><span class="markdown">/<span class="hljs-strong">**</span></span></span><span class="hljs-comment"><span class="markdown">   \<span class="hljs-emphasis">* <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span>通过Feign伪Http客户端调用service-hi提供的服务<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span></span></span><span class="hljs-comment"><span class="markdown">  @GetMapping(&quot;/hi/&#123;name&#125;&quot;)</span></span><span class="hljs-comment"><span class="markdown">  String sayHiFromServiceHi2(@PathVariable(value = &quot;name&quot;) String name);</span></span><span class="hljs-comment"><span class="markdown">&#125;</span></span></code></pre><p>2、修改熔断器ServiceHiHystrix（新的消费熔断器）</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceHiHystrix</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServiceHi</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHiFromServiceHi2</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span> + name +<span class="hljs-string">&quot;, this message send failed. By Hystrix.&quot;</span>;    &#125;&#125;</code></pre><p>3、当然，随之更改的是HelloController，需要改为<code>return serviceHi.sayHiFromServiceHi2</code></p><pre><code class="hljs less"><span class="hljs-variable">@RestController</span>public class HelloController &#123;    <span class="hljs-comment">/** 注入服务&quot;service-hi&quot;的Feign客户端ServiceHi */</span>    <span class="hljs-variable">@Autowired</span>    private ServiceHi serviceHi;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 调用Feign客户端提供的服务，自带负载均衡</span><span class="hljs-comment">     * @param name</span><span class="hljs-comment">     * @return</span><span class="hljs-comment">     */</span>    <span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/hello/&#123;name&#125;&quot;</span>)    public String sayHi(<span class="hljs-variable">@PathVariable</span> String name)&#123;        <span class="hljs-comment">//调用Feign客户端ScheduleServiceHi的接口</span>        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">serviceHi</span><span class="hljs-selector-class">.sayHiFromServiceHi2</span>(name);    &#125;&#125;</code></pre><p>这样改完后，重启这个8766的服务消费者。</p><p>最后得到：</p><p><img src="/blogimg/image-20200430161110248.png" alt="image-20200430161110248"></p><ul><li>上方两排：不同的熔断器</li><li>下方两排：不同的消费提供者</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是Hystrix之熔断和降级&quot;&gt;&lt;a href=&quot;#什么是Hystrix之熔断和降级&quot; class=&quot;headerlink&quot; title=&quot;什么是Hystrix之熔断和降级&quot;&gt;&lt;/a&gt;什么是Hystrix之熔断和降级&lt;/h1&gt;&lt;p&gt;官方:在分布式环境中，不可避</summary>
      
    
    
    
    <category term="SpringCloud" scheme="http://example.com/categories/SpringCloud/"/>
    
    
    <category term="SpringCloud" scheme="http://example.com/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>4.远程调用服务</title>
    <link href="http://example.com/2020/04/30/SpringCloud/4.%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1/"/>
    <id>http://example.com/2020/04/30/SpringCloud/4.%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1/</id>
    <published>2020-04-29T23:29:39.717Z</published>
    <updated>2020-09-08T07:24:46.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、需要三个角色"><a href="#1、需要三个角色" class="headerlink" title="1、需要三个角色"></a>1、需要三个角色</h1><p>服务注册中心（eureka-server）、服务提供者（data-server）、服务消费者，其中服务注册中心就是我们上一篇的Eureka单机版启动既可，流程是首先启动注册中心，服务提供者生产服务并注册到服务中心中，消费者从服务中心中获取服务并执行。</p><h1 id="服务提供者：使用data-server"><a href="#服务提供者：使用data-server" class="headerlink" title="服务提供者：使用data-server"></a>服务提供者：使用data-server</h1><p>子模块不需要做更改。</p><p>可以使用**@EnableDiscoveryClient代替@EnableEurekaClient**</p><h2 id="两者区别："><a href="#两者区别：" class="headerlink" title="两者区别："></a>两者区别：</h2><p>注解@EnableEurekaClient上有@EnableDiscoveryClient注解，可以说基本就是@EnableEurekaClient上有@EnableDiscoveryClient功能，另外上面的注释中提到，其实@EnableEurekaClient注解就是一种方便使用eureka的注解而已，可以说使用其他的注册中心后，都可以使用@EnableDiscoveryClient注解，但是使用@EnableEurekaClient的情景，就是在服务采用eureka作为注册中心的时候，使用场景较为单一。</p><h1 id="服务消费者：新建service-feign子模块"><a href="#服务消费者：新建service-feign子模块" class="headerlink" title="服务消费者：新建service-feign子模块"></a>服务消费者：新建service-feign子模块</h1><p>创建子模块service-feign</p><p>pom.xml</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.test.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.test.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>service-feign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>service-feign<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>服务消费者<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><h2 id="然后在主程序引入："><a href="#然后在主程序引入：" class="headerlink" title="然后在主程序引入："></a>然后在主程序引入：</h2><pre><code class="hljs less"><span class="hljs-variable">@EnableFeignClients</span><span class="hljs-variable">@EnableEurekaClient</span></code></pre><h2 id="之后，修改application-yml"><a href="#之后，修改application-yml" class="headerlink" title="之后，修改application.yml"></a>之后，修改application.yml</h2><pre><code class="hljs less"><span class="hljs-attribute">server</span>:  <span class="hljs-attribute">port</span>: <span class="hljs-number">8766</span><span class="hljs-attribute">spring</span>:  <span class="hljs-attribute">application</span>:    <span class="hljs-attribute">name</span>: service-feign-<span class="hljs-number">2</span><span class="hljs-attribute">eureka</span>:  <span class="hljs-attribute">client</span>:    <span class="hljs-attribute">service-url</span>:      <span class="hljs-attribute">defaultZone</span>: <span class="hljs-attribute">http</span>:<span class="hljs-comment">//localhost:8761/eureka</span></code></pre><h1 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h1><p>首先回顾一下data-server，它提供了一个上述eureka-hi服务提供了一个RESTful风格的接口：</p><p>TestController.java</p><pre><code class="hljs kotlin"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">    *  获取端口号</span><span class="hljs-comment">    * */</span>    <span class="hljs-meta">@Value(<span class="hljs-meta-string">&quot;<span class="hljs-subst">$&#123;server.port&#125;</span>&quot;</span>)</span>    <span class="hljs-keyword">private</span> String port;    <span class="hljs-comment">/*</span><span class="hljs-comment">    *  定义一个简单接口</span><span class="hljs-comment">    * */</span>    <span class="hljs-meta">@GetMapping(<span class="hljs-meta-string">&quot;/hi/&#123;name&#125;&quot;</span>)</span>    <span class="hljs-keyword">public</span> String home(<span class="hljs-meta">@PathVariable</span> String name)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hi &quot;</span> + name + <span class="hljs-string">&quot;,I am from port :&quot;</span> + port;    &#125;&#125;</code></pre><ul><li>行为：GET</li><li>资源：/hi/{name}</li></ul><p>在service-feign模块中编写调用data-server提供的接口的本地接口ServiceHi.java,如下：</p><pre><code class="hljs less"><span class="hljs-comment">/**</span><span class="hljs-comment"> * &lt;p&gt;一个Feign服务消费者接口&lt;/p&gt;</span><span class="hljs-comment"> **/</span><span class="hljs-variable">@FeignClient</span>(value = <span class="hljs-string">&quot;data-server&quot;</span>)public interface ServiceHi &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * &lt;p&gt;通过Feign伪Http客户端调用service-hi提供的服务&lt;/p&gt;</span><span class="hljs-comment">     **/</span>    <span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/hi/&#123;name&#125;&quot;</span>)    String sayHiFromServiceHi(<span class="hljs-variable">@PathVariable</span>(value = <span class="hljs-string">&quot;name&quot;</span>) String name);&#125;</code></pre><p>说明：</p><p>​    —通过@FeignClient标识当前接口是一个Feign客户端，<code>value = &quot;data-server&quot;</code>表示其针对的是名为data-server的服务。</p><p>​    — data-server则是我们data-server子模块的spring.application.name，这个name已经在eureka注册过。</p><p>​    — sayHiFromServiceHi方法为伪成Http客户端方法，与data-server的[GET] /hi/{name} 服务接口相对应。</p><p>之后，新建HelloController.java</p><pre><code class="hljs css"><span class="hljs-selector-tag">package</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.springcloud</span><span class="hljs-selector-class">.controller</span>;<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.springcloud</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.ServiceHi</span>;<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.beans</span><span class="hljs-selector-class">.factory</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.Autowired</span>;<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.bind</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.GetMapping</span>;<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.bind</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.PathVariable</span>;<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.bind</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.RestController</span>;<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">javax</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.Resource</span>;<span class="hljs-comment">/*</span><span class="hljs-comment">* 服务消费控制层</span><span class="hljs-comment">* */</span><span class="hljs-keyword">@RestController</span>public class HelloController &#123;    <span class="hljs-keyword">@Resource</span>    private ServiceHi serviceHi;    <span class="hljs-keyword">@GetMapping</span>(&quot;/hello/&#123;<span class="hljs-selector-tag">name</span>&#125;&quot;)    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">String</span> <span class="hljs-selector-tag">sayHi</span>(<span class="hljs-keyword">@PathVariable</span> String name)&#123;        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">serviceHi</span><span class="hljs-selector-class">.sayHiFromServiceHi</span>(<span class="hljs-selector-tag">name</span>);    &#125;&#125;</code></pre><p>重点：</p><p>​    —— serviceHi.sayHiFromServiceHi(name)即通过Feign调用伪Http客户端的服务接口。</p><p>已经全部配置完毕，依次启动eureka-server、data-server和service-feign。可以看到俩个服务都已经在eureka注册。</p><p>访问 <a href="http://localhost:8765/hello/test">http://localhost:8765/hello/test</a> ，即service-feign提供的服务接口。这个服务接口会通过Feign去调用服务data-server提供的服务接口。</p><p>在该调用中，Feign并不需要指定端口号，它并不知道这个方法所在的服务提供者现在在哪个端口运行，我们只需要向eureka寻求服务。</p><p>三个模块的拓扑图如下：</p><p><img src="/blogimg/640-8210992.png" alt="在这里插入图片描述"></p><h1 id="测试Feign负载均衡"><a href="#测试Feign负载均衡" class="headerlink" title="测试Feign负载均衡"></a>测试Feign负载均衡</h1><p>Feign会对服务调用进行负载平衡，需要同时打开两个data-server服务，由于在同一台电脑上，就得把端口号从8763改为8764，然后同时开启8763和8764两个服务。</p><p>要同时运行两个端口不同的相同服务，需要在run configuration里面把allow parallle打开：</p><p>可以看到有两个data-server进行了注册。</p><p>访问<a href="http://localhost:8765/hello/test%E3%80%82">http://localhost:8765/hello/test。</a></p><p>连续访问两次，发现两次会分别取调用data-server的两个服务节点。</p><p>最后是负载平衡的拓扑图：</p><p><img src="/blogimg/640-8211700.jpeg" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1、需要三个角色&quot;&gt;&lt;a href=&quot;#1、需要三个角色&quot; class=&quot;headerlink&quot; title=&quot;1、需要三个角色&quot;&gt;&lt;/a&gt;1、需要三个角色&lt;/h1&gt;&lt;p&gt;服务注册中心（eureka-server）、服务提供者（data-server）、服务消费者</summary>
      
    
    
    
    <category term="SpringCloud" scheme="http://example.com/categories/SpringCloud/"/>
    
    
    <category term="SpringCloud" scheme="http://example.com/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>Nginx配置</title>
    <link href="http://example.com/2020/04/27/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/nginx%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2020/04/27/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/nginx%E9%85%8D%E7%BD%AE/</id>
    <published>2020-04-27T00:39:34.113Z</published>
    <updated>2020-09-08T06:59:42.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h1><p>Nginx是一款轻量级的网页服务器、反向代理服务器。相较于Apache、lighttpd具有占有内存少，稳定性高等优势。<strong>它最常的用途是提供反向代理服务。</strong></p><h1 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h1><h2 id="a、准备工作"><a href="#a、准备工作" class="headerlink" title="a、准备工作"></a>a、准备工作</h2><p>Nginx的安装依赖于以下三个包，意思就是在安装Nginx之前首先必须安装一下的三个包，注意安装顺序如下：</p><p>　　1 SSL功能需要openssl库，直接通过yum安装: #yum install openssl</p><p>　　2 gzip模块需要zlib库，直接通过yum安装: #yum install zlib</p><p>　　3 rewrite模块需要pcre库，直接通过yum安装: #yum install pcre</p><h2 id="b、安装Nginx依赖项和Nginx"><a href="#b、安装Nginx依赖项和Nginx" class="headerlink" title="b、安装Nginx依赖项和Nginx"></a>b、安装Nginx依赖项和Nginx</h2><h3 id="1-使用yum安装nginx需要包括Nginx的库，安装Nginx的库"><a href="#1-使用yum安装nginx需要包括Nginx的库，安装Nginx的库" class="headerlink" title="　　1 使用yum安装nginx需要包括Nginx的库，安装Nginx的库"></a>　　1 使用yum安装nginx需要包括Nginx的库，安装Nginx的库</h3><p>　　　　#rpm -Uvh <a href="http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm">http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</a></p><h3 id="2-使用下面命令安装nginx"><a href="#2-使用下面命令安装nginx" class="headerlink" title="　　2 使用下面命令安装nginx"></a>　　2 使用下面命令安装nginx</h3><p>　　　　#yum install nginx</p><h3 id="3-启动Nginx"><a href="#3-启动Nginx" class="headerlink" title="　　3 启动Nginx"></a>　　3 启动Nginx</h3><p>　　　　#service nginx start</p><h1 id="3、直接浏览器访问localhost就会出现Nginx的欢迎界面表示安装成功，否则就是失败了"><a href="#3、直接浏览器访问localhost就会出现Nginx的欢迎界面表示安装成功，否则就是失败了" class="headerlink" title="3、直接浏览器访问localhost就会出现Nginx的欢迎界面表示安装成功，否则就是失败了"></a>3、直接浏览器访问localhost就会出现Nginx的欢迎界面表示安装成功，否则就是失败了</h1><p>　默认80端口加入防火墙访问白名单中：firewall-cmd –permanent –zone=public –add-port=80/tcp</p><p>　　使用firewall-cmd –reload命令使其生效</p><h1 id="4、配置Nginx"><a href="#4、配置Nginx" class="headerlink" title="4、配置Nginx"></a>4、配置Nginx</h1><pre><code class="hljs stata"><span class="hljs-keyword">cd</span> /usr/<span class="hljs-keyword">local</span>/nginx/<span class="hljs-keyword">conf</span><span class="hljs-keyword">ls</span>vi nginx.<span class="hljs-keyword">conf</span></code></pre><p>ls</p><p>vi nginx.con</p><p><img src="/blogimg/image-20200427091420834.png" alt="image-20200427091420834"></p><p>详细介绍：<a href="https://yq.aliyun.com/articles/700682">https://yq.aliyun.com/articles/700682</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1、简介&quot;&gt;&lt;a href=&quot;#1、简介&quot; class=&quot;headerlink&quot; title=&quot;1、简介&quot;&gt;&lt;/a&gt;1、简介&lt;/h1&gt;&lt;p&gt;Nginx是一款轻量级的网页服务器、反向代理服务器。相较于Apache、lighttpd具有占有内存少，稳定性高等优势。&lt;s</summary>
      
    
    
    
    <category term="Nginx" scheme="http://example.com/categories/Nginx/"/>
    
    
    <category term="服务器搭建" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    
    <category term="Nginx" scheme="http://example.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>1.穿件密码并登陆</title>
    <link href="http://example.com/2020/04/27/%E6%9C%8D%E5%8A%A1%E5%99%A8/MySQL/1.%E5%88%9B%E5%BB%BA%E5%AF%86%E7%A0%81%E5%B9%B6%E7%99%BB%E9%99%86/"/>
    <id>http://example.com/2020/04/27/%E6%9C%8D%E5%8A%A1%E5%99%A8/MySQL/1.%E5%88%9B%E5%BB%BA%E5%AF%86%E7%A0%81%E5%B9%B6%E7%99%BB%E9%99%86/</id>
    <published>2020-04-27T00:12:07.817Z</published>
    <updated>2020-09-15T02:02:19.893Z</updated>
    
    <content type="html"><![CDATA[<p>1、无密码</p><p>通过Yum安装的mysql的管理员账户是没有密码的，这里通过命令设置其密码为 <strong>admin</strong> </p><p><code>mysqladmin -u root password admin</code></p><p>2、登陆验证</p><p><code>mysql -uroot -padmin</code></p><p><code>show databases;</code></p><h1 id="卸载重装"><a href="#卸载重装" class="headerlink" title="卸载重装"></a>卸载重装</h1><p><a href="https://blog.csdn.net/u011262200/article/details/81049725">https://blog.csdn.net/u011262200/article/details/81049725</a></p><p>优秀解决问题：<a href="https://blog.csdn.net/luowenmin/article/details/81945548">https://blog.csdn.net/luowenmin/article/details/81945548</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、无密码&lt;/p&gt;
&lt;p&gt;通过Yum安装的mysql的管理员账户是没有密码的，这里通过命令设置其密码为 &lt;strong&gt;admin&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;code&gt;mysqladmin -u root password admin&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="服务器搭建" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>1.安装JDK</title>
    <link href="http://example.com/2020/04/27/%E6%9C%8D%E5%8A%A1%E5%99%A8/JDK/1%E3%80%81%E5%AE%89%E8%A3%85JDK/"/>
    <id>http://example.com/2020/04/27/%E6%9C%8D%E5%8A%A1%E5%99%A8/JDK/1%E3%80%81%E5%AE%89%E8%A3%85JDK/</id>
    <published>2020-04-27T00:05:40.963Z</published>
    <updated>2020-09-08T06:54:46.577Z</updated>
    
    <content type="html"><![CDATA[<p>1、安装JDK</p><p><code>yum -y install java-1.8.0-openjdk.x86_64</code></p><p>2、运行</p><p><code>java -version</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、安装JDK&lt;/p&gt;
&lt;p&gt;&lt;code&gt;yum -y install java-1.8.0-openjdk.x86_64&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2、运行&lt;/p&gt;
&lt;p&gt;&lt;code&gt;java -version&lt;/code&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="JDK" scheme="http://example.com/categories/JDK/"/>
    
    
    <category term="服务器搭建" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>0.安装mysql</title>
    <link href="http://example.com/2020/04/27/%E6%9C%8D%E5%8A%A1%E5%99%A8/MySQL/0.%E5%AE%89%E8%A3%85mysql/"/>
    <id>http://example.com/2020/04/27/%E6%9C%8D%E5%8A%A1%E5%99%A8/MySQL/0.%E5%AE%89%E8%A3%85mysql/</id>
    <published>2020-04-27T00:05:20.721Z</published>
    <updated>2020-09-08T06:57:26.947Z</updated>
    
    <content type="html"><![CDATA[<p>1、下载</p><pre><code class="hljs apache"><span class="hljs-attribute">cd</span> /tmp<span class="hljs-attribute">wget</span> http://repo.mysql.com/mysql-community-release-el<span class="hljs-number">7</span>-<span class="hljs-number">5</span>.noarch.rpm  <span class="hljs-attribute">rpm</span> -ivh mysql-community-release-el<span class="hljs-number">7</span>-<span class="hljs-number">5</span>.noarch.rpm</code></pre><p> 2、通过yum进行安装</p><p><code>yum install mysql mysql-server mysql-devel -y</code></p><p>3、启动</p><p><code>systemctl start mysql.service</code></p><p>4、验证</p><p>安装后会自动启动，启动后会占用3306端口。 使用如下命令查看3306端口是否启动，如果启动了则表示mysql处于运行状态。</p><p><code>netstat -anp|grep 3306</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、下载&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs apache&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;cd&lt;/span&gt; /tmp
&lt;span class=&quot;hljs-attribute&quot;&gt;wget&lt;/span&gt; http://repo.</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="服务器搭建" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>6.重启vsftpd服务器</title>
    <link href="http://example.com/2020/04/25/%E6%9C%8D%E5%8A%A1%E5%99%A8/FTP/6.%E9%87%8D%E5%90%AFvsftpd%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://example.com/2020/04/25/%E6%9C%8D%E5%8A%A1%E5%99%A8/FTP/6.%E9%87%8D%E5%90%AFvsftpd%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2020-04-25T04:49:24.237Z</published>
    <updated>2020-09-08T06:51:47.856Z</updated>
    
    <content type="html"><![CDATA[<p>1、重启使用vsftpd服务器</p><p>通常重启使用的命令是：</p><p><code>systemctl restart vsftpd.service</code></p><p>最后执行查看状态，以查看重启成功了：</p><p><code>systemctl status vsftpd.service</code></p><p>2、开放端口</p><p>a、端口概念</p><p>要访问Linux的端口，必须开通才行。</p><p>再买ECS服务器是，只开通了22和3389端口。22就是SecureCRT链接Linux服务器用的端口号。3389 是阿里云控制台链接用的端口，这里没有用到。</p><p>只有这两个端口号是不够用的，为了能够链接vsftpd服务器还需要开放21端口和 30000-30010端口</p><p>b、安全组</p><p>既然用的是阿里云，那么我们就借助阿里云的安全组操作来实现端口的开放效果。<br>登陆阿里云后，按照如下顺序选择：云服务器ECS-&gt;安全组-&gt;配置规则</p><p><img src="/images/blogimg/6977.png" alt="img"></p><p>c、当前安全组规则一览</p><p>目前安全组规则是3个，分别是22，3389和ICMP协议。</p><p>然后点右上角的 <strong>添加安全组规则</strong></p><p><img src="/images/blogimg/6978.png" alt="img"></p><p>d、添加21端口和30000-30010端口</p><p>如图所示只需要修改两个：<br>端口范围： 21/21 表示从21开始，到21结束<br>授权对象： 0.0.0.0/0 表示所有的ip地址都可以访问该端口，重复上述步骤</p><p><img src="/blogimg/6979.png" alt="img"></p><p>e、添加后安全组规则一览</p><p>如图所示，增加了两个新的规则</p><p><img src="/blogimg/6981.png" alt="img"></p><p>3、Transmit连接ftp</p><p><img src="/blogimg/image-20200425130914585.png" alt="image-20200425130914585"></p><p>上传下载拖拉移动。</p><p>上传文件路径：<code>/home/ftp/ftptest</code>也可以在该路径下自己创建新的文件夹。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、重启使用vsftpd服务器&lt;/p&gt;
&lt;p&gt;通常重启使用的命令是：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;systemctl restart vsftpd.service&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最后执行查看状态，以查看重启成功了：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;systemctl </summary>
      
    
    
    
    <category term="FTP" scheme="http://example.com/categories/FTP/"/>
    
    
    <category term="服务器搭建" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    
    <category term="FTP" scheme="http://example.com/tags/FTP/"/>
    
  </entry>
  
  <entry>
    <title>5.用户鉴权</title>
    <link href="http://example.com/2020/04/25/%E6%9C%8D%E5%8A%A1%E5%99%A8/FTP/5.%E7%94%A8%E6%88%B7%E9%89%B4%E6%9D%83/"/>
    <id>http://example.com/2020/04/25/%E6%9C%8D%E5%8A%A1%E5%99%A8/FTP/5.%E7%94%A8%E6%88%B7%E9%89%B4%E6%9D%83/</id>
    <published>2020-04-25T04:43:47.593Z</published>
    <updated>2020-09-08T06:51:33.789Z</updated>
    
    <content type="html"><![CDATA[<p>1、关于鉴权</p><p>因为用户 ftptest 是 nologin的，所以存在鉴权的问题。 如果鉴权问题不解决，就是永不停息的 530错误</p><p>2、鉴权方式</p><p>a、pam.d/vsftpd文件</p><p><code>vi /etc/pam.d/vsftpd</code></p><p>注释掉/etc/pam.d/vsftpd文件里这一行：<br>#auth required pam_shells.so<br>这样不去鉴权，从而允许 ftptest 这种 nologin用户登录 ftp 服务器.</p><p>b、shells文件</p><p><code>vi /etc/shells</code></p><p>在/etc/shells文件里面增加一行：</p><p><code>/sbin/nologin</code></p><p>这样允许不能登录系统的用户通过鉴权</p><p><img src="/blogimg/image-20200425124837000.png" alt="image-20200425124837000"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、关于鉴权&lt;/p&gt;
&lt;p&gt;因为用户 ftptest 是 nologin的，所以存在鉴权的问题。 如果鉴权问题不解决，就是永不停息的 530错误&lt;/p&gt;
&lt;p&gt;2、鉴权方式&lt;/p&gt;
&lt;p&gt;a、pam.d/vsftpd文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vi /etc/pam.d</summary>
      
    
    
    
    <category term="FTP" scheme="http://example.com/categories/FTP/"/>
    
    
    <category term="服务器搭建" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    
    <category term="FTP" scheme="http://example.com/tags/FTP/"/>
    
  </entry>
  
</feed>
