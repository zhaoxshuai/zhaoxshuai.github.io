<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>集合</title>
    <link href="/2020/09/24/On%20Java8/%E9%9B%86%E5%90%88/"/>
    <url>/2020/09/24/On%20Java8/%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="集合："><a href="#集合：" class="headerlink" title="集合："></a>集合：</h1><p>List、Set、Queue（队列） 映射：Map</p><h1 id="栈（Stack）：后进先出"><a href="#栈（Stack）：后进先出" class="headerlink" title="栈（Stack）：后进先出"></a>栈（Stack）：后进先出</h1><p>压入（push）、出栈（pop）</p><p>java6加入ArrayDeque替代Stack：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackTest</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Deque&lt;String&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    <span class="hljs-keyword">for</span>(String s : <span class="hljs-string">&quot;My dog has fleas&quot;</span>.split(<span class="hljs-string">&quot; &quot;</span>))      stack.push(s);    <span class="hljs-keyword">while</span>(!stack.isEmpty())      System.out.print(stack.pop() + <span class="hljs-string">&quot; &quot;</span>);  &#125;&#125;<span class="hljs-comment">/* Output:</span><span class="hljs-comment">fleas has dog My</span><span class="hljs-comment">*/</span></code></pre><h1 id="队列Queue："><a href="#队列Queue：" class="headerlink" title="队列Queue："></a>队列Queue：</h1>]]></content>
    
    
    <categories>
      
      <category>On java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>On java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis数据类型及操作</title>
    <link href="/2020/09/23/Redis/Redis/"/>
    <url>/2020/09/23/Redis/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis五大数据类型："><a href="#Redis五大数据类型：" class="headerlink" title="Redis五大数据类型："></a>Redis五大数据类型：</h1><p>String（字符串）、Hash（哈希，类似java中的Map）、List（列表）、Set（集合）、Zset（sorted set,有序集合）</p><h1 id="操作命令："><a href="#操作命令：" class="headerlink" title="操作命令："></a>操作命令：</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>DEL key</td><td>该命令用于在 key 存在时删除 key。</td></tr><tr><td>DUMP key</td><td>序列化给定 key ，并返回被序列化的值。</td></tr><tr><td>EXISTS key</td><td>检查给定 key 是否存在。</td></tr><tr><td>EXPIRE key seconds</td><td>为给定 key 设置过期时间，以秒计。</td></tr><tr><td>EXPIREAT key timestamp</td><td>EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</td></tr><tr><td>PEXPIRE key milliseconds</td><td>设置 key 的过期时间以毫秒计。</td></tr><tr><td>PEXPIREAT key milliseconds-timestamp</td><td>设置 key 过期时间的时间戳(unix timestamp) 以毫秒计</td></tr><tr><td>KEYS pattern</td><td>查找所有符合给定模式( pattern)的 key 。</td></tr><tr><td>MOVE key db</td><td>将当前数据库的 key 移动到给定的数据库 db 当中。</td></tr><tr><td>PERSIST key</td><td>移除 key 的过期时间，key 将持久保持。</td></tr><tr><td>PTTL key</td><td>以毫秒为单位返回 key 的剩余的过期时间。</td></tr><tr><td>TTL key</td><td>以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。</td></tr><tr><td>RANDOMKEY</td><td>从当前数据库中随机返回一个 key 。</td></tr><tr><td>RENAME key newkey</td><td>修改 key 的名称</td></tr><tr><td>RENAMENX key newkey</td><td>仅当 newkey 不存在时，将 key 改名为 newkey 。</td></tr><tr><td>SCAN cursor [MATCH pattern] [COUNT count]</td><td>迭代数据库中的数据库键。</td></tr><tr><td>TYPE key</td><td>返回 key 所储存的值的类型。</td></tr></tbody></table><h2 id="key："><a href="#key：" class="headerlink" title="key："></a>key：</h2><pre><code class="hljs routeros">Keys * :查询所有键值exists key的名字:判断某个key是否存在move key的名字 db库的标号：将该库的键值移动到标号库，该库移除exprie key的名字 秒钟：设置键的过期时间，过期将被移除ttl key:查看剩余多长时间过期，-1永不过期，-2已过期type key:查看key为什么类型</code></pre><p><img src="/blogimg/image-20200925093842215.png" alt="image-20200925093842215"></p><h2 id="String："><a href="#String：" class="headerlink" title="String："></a>String：</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>SET key value</td><td>设置指定 key 的值</td></tr><tr><td>GET key</td><td>获取指定 key 的值。</td></tr><tr><td>GETRANGE key start end</td><td>返回 key 中字符串值的子字符</td></tr><tr><td>GETSET key value</td><td>将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</td></tr><tr><td>GETBIT key offset</td><td>对 key 所储存的字符串值，获取指定偏移量上的位(bit)。</td></tr><tr><td>MGET key1 [key2..]</td><td>获取所有(一个或多个)给定 key 的值。</td></tr><tr><td>SETBIT key offset value</td><td>对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</td></tr><tr><td>SETEX key seconds value</td><td>将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。</td></tr><tr><td>SETNX key value</td><td>只有在 key 不存在时设置 key 的值。</td></tr><tr><td>SETRANGE key offset value</td><td>用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。</td></tr><tr><td>STRLEN key</td><td>返回 key 所储存的字符串值的长度。</td></tr><tr><td>MSET key value [key value …]</td><td>同时设置一个或多个 key-value 对。</td></tr><tr><td>MSETNX key value [key value …]</td><td>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</td></tr><tr><td>PSETEX key milliseconds value</td><td>这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。</td></tr><tr><td>INCR key</td><td>将 key 中储存的数字值增一。</td></tr><tr><td>INCRBY key increment</td><td>将 key 所储存的值加上给定的增量值（increment） 。</td></tr><tr><td>INCRBYFLOAT key increment</td><td>将 key 所储存的值加上给定的浮点增量值（increment） 。</td></tr><tr><td>DECR key</td><td>将 key 中储存的数字值减一。</td></tr><tr><td>DECRBY key decrement</td><td>key 所储存的值减去给定的减量值（decrement） 。</td></tr><tr><td>APPEND key value</td><td>如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。</td></tr></tbody></table><p>案例：</p><pre><code class="hljs awk">set<span class="hljs-regexp">/get/</span>del<span class="hljs-regexp">/append/</span>strlen:设值<span class="hljs-regexp">/获取值/</span>删除键值<span class="hljs-regexp">/追加值/</span>值长度incr<span class="hljs-regexp">/decr/i</span>ncrby<span class="hljs-regexp">/dectby:增1/</span>减<span class="hljs-number">1</span><span class="hljs-regexp">/将 key 所储存的值加上给定的增量值（increment）/</span>将 key 所储存的值减去给定的增量值（increment）(值必须为数字才能进行加减)。getrange/setrange:mset<span class="hljs-regexp">/mget/m</span>setnx:可以多组操作getset：先get在set</code></pre><p><img src="/blogimg/image-20200925103802045.png" alt="image-20200925103802045"></p><h2 id="List：（单值多value）"><a href="#List：（单值多value）" class="headerlink" title="List：（单值多value）"></a>List：（单值多value）</h2><h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>BLPOP key1 [key2 ] timeout</td><td>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td>BRPOP key1 [key2 ] timeout</td><td>移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td>BRPOPLPUSH source destination timeout</td><td>从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td>LINDEX key index</td><td>通过索引获取列表中的元素</td></tr><tr><td>LINSERT key BEFORE/AFTER pivot value</td><td>在列表的元素前或者后插入元素</td></tr><tr><td>LLEN key</td><td>获取列表长度</td></tr><tr><td>LPOP key</td><td>移出并获取列表的第一个元素</td></tr><tr><td>LPUSH key value1 [value2]</td><td>将一个或多个值插入到列表头部</td></tr><tr><td>LPUSHX key value</td><td>将一个值插入到已存在的列表头部</td></tr><tr><td>LRANGE key start stop</td><td>获取列表指定范围内的元素</td></tr><tr><td>LREM key count value</td><td>移除列表元素</td></tr><tr><td>LSET key index value</td><td>通过索引设置列表元素的值</td></tr><tr><td>LTRIM key start stop</td><td>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</td></tr><tr><td>RPOP key</td><td>移除列表的最后一个元素，返回值为移除的元素。</td></tr><tr><td>RPOPLPUSH source destination</td><td>移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td></tr><tr><td>RPUSH key value1 [value2]</td><td>在列表中添加一个或多个值</td></tr><tr><td>RPUSHX key value</td><td>为已存在的列表添加值</td></tr></tbody></table><pre><code class="hljs tcl">lpush/rpush/<span class="hljs-keyword">lrange</span>:入/出lpop/rpop:出并移除<span class="hljs-keyword">lindex</span>:按照索引下表或得元素llen key:获取长度lrem key：删n个valueltrim key 开始index 结束index：截取指定范围的值后再赋值给keyrpoplpush 源列表 目的列表:底出顶进<span class="hljs-keyword">linsert</span> key before/<span class="hljs-keyword">after</span> 值<span class="hljs-number">1</span> 值<span class="hljs-number">2</span>:值<span class="hljs-number">1</span>问列表中有的值，在这个值之前之后插入</code></pre><p><img src="/blogimg/image-20200925110729421.png" alt="image-20200925110729421"></p><p><img src="/blogimg/image-20200925110759998.png" alt="image-20200925110759998"></p><p><img src="/blogimg/image-20200925114352958.png" alt="image-20200925114352958"></p><p>性能总结：</p><ul><li>它是一个字符串链表，left、right都可以插入添加；</li><li>如果键不存在，创建新的链表；</li><li>如果键已存在，新增内容；</li><li>如果值全移除，对应的键也就消失了。</li><li>链表的操作无论是头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡了。</li></ul><h2 id="Set-单值多value-（不会有重复数据）"><a href="#Set-单值多value-（不会有重复数据）" class="headerlink" title="Set:(单值多value)（不会有重复数据）"></a>Set:(单值多value)（不会有重复数据）</h2><h3 id="常用-1"><a href="#常用-1" class="headerlink" title="常用"></a>常用</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>SADD key member1 [member2]</td><td>向集合添加一个或多个成员</td></tr><tr><td>SCARD key</td><td>获取集合的成员数</td></tr><tr><td>SDIFF key1 [key2]</td><td>返回给定所有集合的差集</td></tr><tr><td>SDIFFSTORE destination key1 [key2]</td><td>返回给定所有集合的差集并存储在 destination 中</td></tr><tr><td>SINTER key1 [key2]</td><td>返回给定所有集合的交集</td></tr><tr><td>SINTERSTORE destination key1 [key2]</td><td>返回给定所有集合的交集并存储在 destination 中</td></tr><tr><td>SISMEMBER key member</td><td>判断 member 元素是否是集合 key 的成员</td></tr><tr><td>SMEMBERS key</td><td>返回集合中的所有成员</td></tr><tr><td>SMOVE source destination member</td><td>将 member 元素从 source 集合移动到 destination 集合</td></tr><tr><td>SPOP key</td><td>移除并返回集合中的一个随机元素</td></tr><tr><td>SRANDMEMBER key [count]</td><td>返回集合中一个或多个随机数</td></tr><tr><td>SREM key member1 [member2]</td><td>移除集合中一个或多个成员</td></tr><tr><td>SUNION key1 [key2]</td><td>返回所有给定集合的并集</td></tr><tr><td>SUNIONSTORE destination key1 [key2]</td><td>所有给定集合的并集存储在 destination 集合中</td></tr><tr><td>SSCAN key cursor [MATCH pattern] [COUNT count]</td><td>迭代集合中的元素</td></tr></tbody></table><ul><li>```<ul><li>sadd/smembers/sismember</li><li>scard，获取集合里面的元素个数</li><li>srem key value 删除集合中元素</li><li>srandmember key 某个整数(随机出几个数)</li><li>spop key 随机出栈</li><li>smove key1 key2 在key1里某个值 作用是将key1里的某个值赋给key2</li><li>数学集合类<ul><li>差集：sdiff</li><li>交集：sinter</li><li>并集：sunion<pre><code class="hljs gherkin">![image-20200925133415606](/blogimg/image-20200925133415606.png)![image-20200925133448672](/blogimg/image-20200925133448672.png)<span class="hljs-comment">## Hash(哈希)：（KV模式，但V是一个键值对）</span><span class="hljs-comment">### 常用</span>|<span class="hljs-string"> 命令                                           </span>|<span class="hljs-string"> 描述                                                     </span>||<span class="hljs-string"> ---------------------------------------------- </span>|<span class="hljs-string"> -------------------------------------------------------- </span>||<span class="hljs-string"> HDEL key field1 [field2]                       </span>|<span class="hljs-string"> 删除一个或多个哈希表字段                                 </span>||<span class="hljs-string"> HEXISTS key field                              </span>|<span class="hljs-string"> 查看哈希表 key 中，指定的字段是否存在。                  </span>||<span class="hljs-string"> HGET key field                                 </span>|<span class="hljs-string"> 获取存储在哈希表中指定字段的值。                         </span>||<span class="hljs-string"> HGETALL key                                    </span>|<span class="hljs-string"> 获取在哈希表中指定 key 的所有字段和值                    </span>||<span class="hljs-string"> HINCRBY key field increment                    </span>|<span class="hljs-string"> 为哈希表 key 中的指定字段的整数值加上增量 increment 。   </span>||<span class="hljs-string"> HINCRBYFLOAT key field increment               </span>|<span class="hljs-string"> 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。 </span>||<span class="hljs-string"> HKEYS key                                      </span>|<span class="hljs-string"> 获取所有哈希表中的字段                                   </span>||<span class="hljs-string"> HLEN key                                       </span>|<span class="hljs-string"> 获取哈希表中字段的数量                                   </span>||<span class="hljs-string"> HMGET key field1 [field2]                      </span>|<span class="hljs-string"> 获取所有给定字段的值                                     </span>||<span class="hljs-string"> HMSET key field1 value1 [field2 value2 ]       </span>|<span class="hljs-string"> 同时将多个 field-value (域-值)对设置到哈希表 key 中。    </span>||<span class="hljs-string"> HSET key field value                           </span>|<span class="hljs-string"> 将哈希表 key 中的字段 field 的值设为 value 。            </span>||<span class="hljs-string"> HSETNX key field value                         </span>|<span class="hljs-string"> 只有在字段 field 不存在时，设置哈希表字段的值。          </span>||<span class="hljs-string"> HVALS key                                      </span>|<span class="hljs-string"> 获取哈希表中所有值。                                     </span>||<span class="hljs-string"> HSCAN key cursor [MATCH pattern] [COUNT count] </span>|<span class="hljs-string"> 迭代哈希表中的键值对。                                   </span>|<span class="hljs-comment">### 案例</span></code></pre></li></ul></li></ul></li><li>hset/hget/hmset/hmget/hgetall/hdel</li><li>hlen</li><li>hexists key 在key里面的某个值的key</li><li>hkeys/hvals</li><li>hincrby/hincrbyfloat</li><li>hsetnx<pre><code class="hljs gherkin">![image-20200925134712063](/blogimg/image-20200925134712063.png)<span class="hljs-comment"># ZSet</span>在set基础上，加一个score值。之前set是k1 v1 v2 v3，现在zset是k1 score1 v1 score2 v2<span class="hljs-comment">## 常用</span>|<span class="hljs-string"> 命令                                           </span>|<span class="hljs-string"> 描述                                                         </span>||<span class="hljs-string"> ---------------------------------------------- </span>|<span class="hljs-string"> ------------------------------------------------------------ </span>||<span class="hljs-string"> ZADD key score1 member1 [score2 member2]       </span>|<span class="hljs-string"> 向有序集合添加一个或多个成员，或者更新已存在成员的分数       </span>||<span class="hljs-string"> ZCARD key                                      </span>|<span class="hljs-string"> 获取有序集合的成员数                                         </span>||<span class="hljs-string"> ZCOUNT key min max                             </span>|<span class="hljs-string"> 计算在有序集合中指定区间分数的成员数                         </span>||<span class="hljs-string"> ZINCRBY key increment member                   </span>|<span class="hljs-string"> 有序集合中对指定成员的分数加上增量 increment                 </span>||<span class="hljs-string"> ZINTERSTORE destination numkeys key [key ...]  </span>|<span class="hljs-string"> 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中 </span>||<span class="hljs-string"> ZLEXCOUNT key min max                          </span>|<span class="hljs-string"> 在有序集合中计算指定字典区间内成员数量                       </span>||<span class="hljs-string"> ZRANGE key start stop [WITHSCORES]             </span>|<span class="hljs-string"> 通过索引区间返回有序集合指定区间内的成员                     </span>||<span class="hljs-string"> ZRANGEBYLEX key min max [LIMIT offset count]   </span>|<span class="hljs-string"> 通过字典区间返回有序集合的成员                               </span>||<span class="hljs-string"> ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] </span>|<span class="hljs-string"> 通过分数返回有序集合指定区间内的成员                         </span>||<span class="hljs-string"> ZRANK key member                               </span>|<span class="hljs-string"> 返回有序集合中指定成员的索引                                 </span>||<span class="hljs-string"> ZREM key member [member ...]                   </span>|<span class="hljs-string"> 移除有序集合中的一个或多个成员                               </span>||<span class="hljs-string"> ZREMRANGEBYLEX key min max                     </span>|<span class="hljs-string"> 移除有序集合中给定的字典区间的所有成员                       </span>||<span class="hljs-string"> ZREMRANGEBYRANK key start stop                 </span>|<span class="hljs-string"> 移除有序集合中给定的排名区间的所有成员                       </span>||<span class="hljs-string"> ZREMRANGEBYSCORE key min max                   </span>|<span class="hljs-string"> 移除有序集合中给定的分数区间的所有成员                       </span>||<span class="hljs-string"> ZREVRANGE key start stop [WITHSCORES]          </span>|<span class="hljs-string"> 返回有序集中指定区间内的成员，通过索引，分数从高到低         </span>||<span class="hljs-string"> ZREVRANGEBYSCORE key max min [WITHSCORES]      </span>|<span class="hljs-string"> 返回有序集中指定分数区间内的成员，分数从高到低排序           </span>||<span class="hljs-string"> ZREVRANK key member                            </span>|<span class="hljs-string"> 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序 </span>||<span class="hljs-string"> ZSCORE key member                              </span>|<span class="hljs-string"> 返回有序集中，成员的分数值                                   </span>||<span class="hljs-string"> ZUNIONSTORE destination numkeys key [key ...]  </span>|<span class="hljs-string"> 计算给定的一个或多个有序集的并集，并存储在新的 key 中        </span>||<span class="hljs-string"> ZSCAN key cursor [MATCH pattern] [COUNT count] </span>|<span class="hljs-string"> 迭代有序集合中的元素（包括元素成员和元素分值）               </span>|<span class="hljs-comment">### 案例</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>@@@@@@@@<span class="hljs-comment"># 配置文件介绍</span>redis的配置文件位于redis的安装目录下，文件名为redis.conf。可以通过config命令查看或设置配置项。实例：</code></pre>redis 127.0.0.1:6379&gt; CONFIG GET loglevel</li></ul><ol><li>“loglevel”</li><li>“notice”<pre><code class="hljs gherkin"><span class="hljs-comment">## 参数说明</span>redis。conf配置项说明如下：（不全）|<span class="hljs-string"> 序号 </span>|<span class="hljs-string"> 配置项                                                       </span>|<span class="hljs-string"> 说明                                                         </span>||<span class="hljs-string"> ---- </span>|<span class="hljs-string"> ------------------------------------------------------------ </span>|<span class="hljs-string"> ------------------------------------------------------------ </span>||<span class="hljs-string"> 1    </span>|<span class="hljs-string"> `daemonize no`                                               </span>|<span class="hljs-string"> Redis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程（Windows 不支持守护线程的配置为 no ） </span>||<span class="hljs-string"> 2    </span>|<span class="hljs-string"> `pidfile /var/run/redis.pid`                                 </span>|<span class="hljs-string"> 当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入 /var/run/redis.pid 文件，可以通过 pidfile 指定 </span>||<span class="hljs-string"> 3    </span>|<span class="hljs-string"> `port 6379`                                                  </span>|<span class="hljs-string"> 指定 Redis 监听端口，默认端口为 6379，作者在自己的一篇博文中解释了为什么选用 6379 作为默认端口，因为 6379 在手机按键上 MERZ 对应的号码，而 MERZ 取自意大利歌女 Alessia Merz 的名字 </span>||<span class="hljs-string"> 4    </span>|<span class="hljs-string"> `bind 127.0.0.1`                                             </span>|<span class="hljs-string"> 绑定的主机地址                                               </span>||<span class="hljs-string"> 5    </span>|<span class="hljs-string"> `timeout 300`                                                </span>|<span class="hljs-string"> 当客户端闲置多长秒后关闭连接，如果指定为 0 ，表示关闭该功能  </span>||<span class="hljs-string"> 6    </span>|<span class="hljs-string"> `loglevel notice`                                            </span>|<span class="hljs-string"> 指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice </span>||<span class="hljs-string"> 7    </span>|<span class="hljs-string"> `logfile stdout`                                             </span>|<span class="hljs-string"> 日志记录方式，默认为标准输出，如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 /dev/null </span>||<span class="hljs-string"> 8    </span>|<span class="hljs-string"> `databases 16`                                               </span>|<span class="hljs-string"> 设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id </span>||<span class="hljs-string"> 9    </span>|<span class="hljs-string"> `save &lt;seconds&gt; &lt;changes&gt;`&lt;br&gt;Redis 默认配置文件中提供了三个条件：&lt;br&gt;`save 900 1`&lt;br&gt;`save 300 10`&lt;br&gt;`save 60 10000`&lt;br&gt; </span>|<span class="hljs-string"> 分别表示 900 秒（15 分钟）内有 1 个更改，300 秒（5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。&lt;br&gt;指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 </span>||<span class="hljs-string"> 10   </span>|<span class="hljs-string"> `rdbcompression yes`                                         </span>|<span class="hljs-string"> 指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大 </span>||<span class="hljs-string"> 11   </span>|<span class="hljs-string"> `dbfilename dump.rdb`                                        </span>|<span class="hljs-string"> 指定本地数据库文件名，默认值为 dump.rdb                      </span>||<span class="hljs-string"> 12   </span>|<span class="hljs-string"> `dir ./`                                                     </span>|<span class="hljs-string"> 指定本地数据库存放目录                                       </span>||<span class="hljs-string"> 13   </span>|<span class="hljs-string"> `slaveof &lt;masterip&gt; &lt;masterport&gt;`                            </span>|<span class="hljs-string"> 设置当本机为 slave 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步 </span>||<span class="hljs-string"> 14   </span>|<span class="hljs-string"> `masterauth &lt;master-password&gt;`                               </span>|<span class="hljs-string"> 当 master 服务设置了密码保护时，slav 服务连接 master 的密码  </span>||<span class="hljs-string"> 15   </span>|<span class="hljs-string"> `requirepass foobared`                                       </span>|<span class="hljs-string"> 设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 AUTH &lt;password&gt; 命令提供密码，默认关闭 </span>||<span class="hljs-string"> 16   </span>|<span class="hljs-string"> `maxclients 128`                                             </span>|<span class="hljs-string"> 设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息 </span>||<span class="hljs-string"> 17   </span>|<span class="hljs-string"> `maxmemory &lt;bytes&gt;`                                          </span>|<span class="hljs-string"> 指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区 </span>||<span class="hljs-string"> 18   </span>|<span class="hljs-string"> `appendonly no`                                              </span>|<span class="hljs-string"> 指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no </span>||<span class="hljs-string"> 19   </span>|<span class="hljs-string"> `appendfilename appendonly.aof`                              </span>|<span class="hljs-string"> 指定更新日志文件名，默认为 appendonly.aof                    </span>||<span class="hljs-string"> 20   </span>|<span class="hljs-string"> `appendfsync everysec`                                       </span>|<span class="hljs-string"> 指定更新日志条件，共有 3 个可选值：&lt;br&gt;no：表示等操作系统进行数据缓存同步到磁盘（快）&lt;br&gt;always：表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）&lt;br&gt;everysec：表示每秒同步一次（折中，默认值）&lt;br&gt; </span>||<span class="hljs-string"> 21   </span>|<span class="hljs-string"> `vm-enabled no`                                              </span>|<span class="hljs-string"> 指定是否启用虚拟内存机制，默认值为 no，简单的介绍一下，VM 机制将数据分页存放，由 Redis 将浏览量较少的页即冷数据 swap 到磁盘上，浏览多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析 Redis 的 VM 机制） </span>||<span class="hljs-string"> 22   </span>|<span class="hljs-string"> `vm-swap-file /tmp/redis.swap`                               </span>|<span class="hljs-string"> 虚拟内存文件路径，默认值为 /tmp/redis.swap，不可多个 Redis 实例共享 </span>||<span class="hljs-string"> 23   </span>|<span class="hljs-string"> `vm-max-memory 0`                                            </span>|<span class="hljs-string"> 将所有大于 vm-max-memory 的数据存入虚拟内存，无论 vm-max-memory 设置多小，所有索引数据都是内存存储的(Redis 的索引数据 就是 keys)，也就是说，当 vm-max-memory 设置为 0 的时候，其实是所有 value 都存在于磁盘。默认值为 0 </span>||<span class="hljs-string"> 24   </span>|<span class="hljs-string"> `vm-page-size 32`                                            </span>|<span class="hljs-string"> Redis swap 文件分成了很多的 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，vm-page-size 是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page 大小最好设置为 32 或者 64bytes；如果存储很大大对象，则可以使用更大的 page，如果不确定，就使用默认值 </span>||<span class="hljs-string"> 25   </span>|<span class="hljs-string"> `vm-pages 134217728`                                         </span>|<span class="hljs-string"> 设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是在放在内存中的，，在磁盘上每 8 个 pages 将消耗 1byte 的内存。 </span>||<span class="hljs-string"> 26   </span>|<span class="hljs-string"> `vm-max-threads 4`                                           </span>|<span class="hljs-string"> 设置连接swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4 </span>||<span class="hljs-string"> 27   </span>|<span class="hljs-string"> `glueoutputbuf yes`                                          </span>|<span class="hljs-string"> 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启 </span>||<span class="hljs-string"> 28   </span>|<span class="hljs-string"> `hash-max-zipmap-entries 64`&lt;br&gt;`hash-max-zipmap-value 512`  </span>|<span class="hljs-string"> 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法 </span>||<span class="hljs-string"> 29   </span>|<span class="hljs-string"> `activerehashing yes`                                        </span>|<span class="hljs-string"> 指定是否激活重置哈希，默认为开启（后面在介绍 Redis 的哈希算法时具体介绍） </span>||<span class="hljs-string"> 30   </span>|<span class="hljs-string"> `include /path/to/local.conf`                                </span>|<span class="hljs-string"> 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件 </span>|<span class="hljs-comment"># 持久化值RDB</span><span class="hljs-comment">### RDB是什么：</span>- 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里- Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</code></pre>Fork</li></ol><p>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</p><pre><code class="hljs clean">- rdb 保存的是dump.rdb文件- 相关配置在配置文件的位置 - 在redis.conf搜寻`### SNAPSHOTTING ###`### 如何触发RDB快照- 配置文件中默认的快照配置</code></pre><p>  dbfilename dump.rdb</p><p>  ```</p><ul><li>冷拷贝后重新使用<ul><li>可以cp dump.rdb dump_new.rdb</li></ul></li></ul><ul><li><p>命令save或者是bgsave</p><ul><li>Save：save时只管保存，其它不管，全部阻塞</li><li>BGSAVE：Redis会在后台异步进行快照操作， 快照同时还可以响应客户端请求。可以通过lastsave 命令获取最后一次成功执行快照的时间</li></ul></li><li><p>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</p></li></ul><h3 id="如何恢复"><a href="#如何恢复" class="headerlink" title="如何恢复"></a>如何恢复</h3><ul><li>将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可</li><li><code>CONFIG GET dir</code>获取目录</li></ul><h3 id="优势与劣势"><a href="#优势与劣势" class="headerlink" title="优势与劣势"></a>优势与劣势</h3><ul><li>优势<ul><li>适合大规模的数据恢复</li><li>对数据完整性和一致性要求不高</li></ul></li><li>劣势<ul><li>在一定间隔时间做一次备份，所以如果redis意外down掉的话，就 会丢失最后一次快照后的所有修改</li><li>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li></ul></li></ul><h3 id="如何停止"><a href="#如何停止" class="headerlink" title="如何停止"></a>如何停止</h3><p>动态所有停止RDB保存规则的方法：<code>redis-cli config set save &quot;&quot;</code></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="https://gitee.com/jallenkwong/LearnRedis/raw/master/image/21.png" alt="img"></p><ul><li>RDB是一个非常紧凑的文件。</li><li>RDB在保存RDB文件时父进程唯一需要做的就是fork出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他I0操作，所以RDB持久化方式可以最大化redis的性能。</li><li>与AOF相比，在恢复大的数据集的时候，RDB方式会更快一一些。</li><li>数据丢失风险大。</li><li>RDB需要经常fork子进程来保存数据集到硬盘上，当数据集比较大的时候fork的过程是非常耗时的吗，可能会导致Redis在一些毫秒级不能回应客户端请求。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NoSQL介绍</title>
    <link href="/2020/09/21/Redis/NoSQL/"/>
    <url>/2020/09/21/Redis/NoSQL/</url>
    
    <content type="html"><![CDATA[<h1 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL:"></a>NoSQL:</h1><p>数据类型：聚合模型</p><h1 id="MongoDB："><a href="#MongoDB：" class="headerlink" title="MongoDB："></a>MongoDB：</h1><p>基于分布式文件存储的数据库。介于关系型数据库和非关系型数据库之间的产品。</p><h1 id="NoSQL数据库的四大类："><a href="#NoSQL数据库的四大类：" class="headerlink" title="NoSQL数据库的四大类："></a>NoSQL数据库的四大类：</h1><p>KV键值、文件型数据库（BSON格式较多）、列存储数据库、图关系数据库。四者比对如下：</p><p><img src="/blogimg/image-20200921222249034.png" alt="image-20200921222249034"></p><h1 id="在分布式数据库中CAP原理CAP-BASE："><a href="#在分布式数据库中CAP原理CAP-BASE：" class="headerlink" title="在分布式数据库中CAP原理CAP+BASE："></a>在分布式数据库中CAP原理CAP+BASE：</h1><h2 id="传统的ACID分别是什么：（关系型数据库）"><a href="#传统的ACID分别是什么：（关系型数据库）" class="headerlink" title="传统的ACID分别是什么：（关系型数据库）"></a>传统的ACID分别是什么：（关系型数据库）</h2><p>A(Atomicity)原子性</p><p>C(Consistency)一致性</p><p>I(Isolation)独立性</p><p>D(Durability)持久性</p><p><img src="/blogimg/image-20200921223104548.png" alt="image-20200921223104548"></p><h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP:"></a>CAP:</h2><p>C:Consisteny(强一致性)</p><p>A:Availability(可用性)</p><p>P:Partition tolerance(分区容错性)</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>控制流</title>
    <link href="/2020/09/09/On%20Java8/%E6%8E%A7%E5%88%B6%E6%B5%81/"/>
    <url>/2020/09/09/On%20Java8/%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="Break和continue关键字用法："><a href="#Break和continue关键字用法：" class="headerlink" title="Break和continue关键字用法："></a>Break和continue关键字用法：</h1><ol><li>简单的一个continue会退回最内层循环的开头（顶部），并继续执行。</li><li>带有标签的continue会到达标签的位置，并重新进入紧接在那个标签后面的循环。</li><li>break会中断当前循环，并移离当前标签的末尾。</li><li>带标签的break会中断当前循环，并移离由那个标签指示的循环末尾。</li></ol><h1 id="this关键字："><a href="#this关键字：" class="headerlink" title="this关键字："></a>this关键字：</h1><p>表示当前对象。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leaf</span> </span>&#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-function">Leaf <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;        i++;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;i = &quot;</span> + i);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Leaf x = <span class="hljs-keyword">new</span> Leaf();        x.increment().increment().increment().print();    &#125;&#125;</code></pre><p>输出：</p><pre><code class="hljs java">i=<span class="hljs-number">3</span></code></pre><h1 id="垃圾回收器如何工作？"><a href="#垃圾回收器如何工作？" class="headerlink" title="垃圾回收器如何工作？"></a>垃圾回收器如何工作？</h1><p>“自适应的、分代的、停止-复制、标记-清扫”式的垃圾回收器。</p><h1 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h1><p>在类中只初始化一次。</p><h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><p>被final修饰的属性不能被修改，修饰的类不能被继承。</p><h1 id="多态："><a href="#多态：" class="headerlink" title="多态："></a>多态：</h1><p>多态提供了另一个维度的接口与实现分离，以解耦做什么和怎么做。多态不仅能改善代码的组织，提高代码的可读性。</p>]]></content>
    
    
    <categories>
      
      <category>On Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>On Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CAS</title>
    <link href="/2020/09/03/%E9%AB%98%E5%B9%B6%E5%8F%91/CAS/"/>
    <url>/2020/09/03/%E9%AB%98%E5%B9%B6%E5%8F%91/CAS/</url>
    
    <content type="html"><![CDATA[<h1 id="CAS："><a href="#CAS：" class="headerlink" title="CAS："></a>CAS：</h1><p>Compare and swap/compare and exchange 比较并且交换</p><p>ABA问题解决：加标签或者版本号</p>]]></content>
    
    
    <categories>
      
      <category>高并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafak环境搭建</title>
    <link href="/2020/09/01/kafka/1.%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/09/01/kafka/1.%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>jdk：<a href="https://www.cnblogs.com/songxingzhu/p/9254749.html">https://www.cnblogs.com/songxingzhu/p/9254749.html</a></p><p>kafka：<a href="https://developer.aliyun.com/article/708277">https://developer.aliyun.com/article/708277</a></p>]]></content>
    
    
    <categories>
      
      <category>Kafak</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafak</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB创建数据库</title>
    <link href="/2020/09/01/MongoDB/1.%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2020/09/01/MongoDB/1.%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="MongoDB连接："><a href="#MongoDB连接：" class="headerlink" title="MongoDB连接："></a>MongoDB连接：</h1><p>执行mongo</p><h1 id="MongoDB创建数据库："><a href="#MongoDB创建数据库：" class="headerlink" title="MongoDB创建数据库："></a>MongoDB创建数据库：</h1><pre><code class="hljs sql"><span class="hljs-keyword">use</span> database_name</code></pre><p>查看数据库：</p><pre><code class="hljs sql"><span class="hljs-keyword">show</span> dbs</code></pre><p>新创建的数据库刚开始会看不到，必须向数据库插入一条数据。</p><pre><code class="hljs sql">db.database_name.insert(&#123;&quot;name&quot;:&quot;XXX&quot;&#125;)</code></pre><p>在执行show dbs,就会看到新建的数据库。</p>]]></content>
    
    
    <categories>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一章 对象的概念</title>
    <link href="/2020/08/31/On%20Java8/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    <url>/2020/08/31/On%20Java8/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p>面向对象编程是一种编程思维方式和编码架构。</p><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>List：常用于保存序列；</p><p>Map：常用于将对象与其他对象关联；</p><p>Set：只能保存非重复的值；</p><p>其他包括队列（Queue）、树（Tree）、栈（Stack）、堆（Heap）等等。</p><h2 id="ArrayList和LinkedList区别："><a href="#ArrayList和LinkedList区别：" class="headerlink" title="ArrayList和LinkedList区别："></a>ArrayList和LinkedList区别：</h2><p>两者具有相同接口和外部行为，但是在某些操作中它们的效率差别很大。在ArrayList中随机查找元素是很高效的，而LinkedList随机查找效率低下。反之，在LinkedList中插入元素的效率要比在ArrayList中高。由于底层数据结构的不同，每种集合类型在执行相同的操作时会表现出效率上的差异。</p><h2 id="面向对象编程的一个优点是："><a href="#面向对象编程的一个优点是：" class="headerlink" title="面向对象编程的一个优点是："></a>面向对象编程的一个优点是：</h2><p>设计良好的java程序代码更容易被人阅读理解。由于java类库的复用性，通常程序要写的代码也会少的多。</p>]]></content>
    
    
    <categories>
      
      <category>On Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>On Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归</title>
    <link href="/2020/08/27/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/"/>
    <url>/2020/08/27/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<h1 id="1、编写递归代码最重要的三点："><a href="#1、编写递归代码最重要的三点：" class="headerlink" title="1、编写递归代码最重要的三点："></a>1、编写递归代码最重要的三点：</h1><ul><li>递归总有一个最简单的情况–方法的第一条语句总是包含return的条件语句。</li><li>递归调用总是尝试解决一个规模更小的子问题，这样递归才能收敛到最简单的情况。</li><li>递归调用的父类问题和尝试解决的子问题之间不应该有交集。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时间复杂度</title>
    <link href="/2020/07/29/%E7%AE%97%E6%B3%95/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <url>/2020/07/29/%E7%AE%97%E6%B3%95/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="算法的时间和空间复杂度："><a href="#算法的时间和空间复杂度：" class="headerlink" title="算法的时间和空间复杂度："></a>算法的时间和空间复杂度：</h1><p>时间复杂度和空间复杂度是用来衡量算法的快慢的。</p><p>引：<a href="https://zhuanlan.zhihu.com/p/50479555">https://zhuanlan.zhihu.com/p/50479555</a></p><p>时间复杂度：看循环</p><p>空间复杂度：看分配空间，比如new对象</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.配置中心Spring Cloud Config初体验</title>
    <link href="/2020/04/30/SpringCloud/6.%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83Spring%20Cloud%20Config%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <url>/2020/04/30/SpringCloud/6.%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83Spring%20Cloud%20Config%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.熔断器Hystrix的使用+可视化监控Dashboard和Turbine</title>
    <link href="/2020/04/30/SpringCloud/5.%E7%86%94%E6%96%AD%E5%99%A8Hystrix%E7%9A%84%E4%BD%BF%E7%94%A8+%20%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9B%91%E6%8E%A7Dashboard%E5%92%8CTurbine/"/>
    <url>/2020/04/30/SpringCloud/5.%E7%86%94%E6%96%AD%E5%99%A8Hystrix%E7%9A%84%E4%BD%BF%E7%94%A8+%20%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9B%91%E6%8E%A7Dashboard%E5%92%8CTurbine/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是Hystrix之熔断和降级"><a href="#什么是Hystrix之熔断和降级" class="headerlink" title="什么是Hystrix之熔断和降级"></a>什么是Hystrix之熔断和降级</h1><p>官方:在分布式环境中，不可避免地会有许多服务依赖项中的某些失败。Hystrix是一个库，可通过添加等待时间容限和容错逻辑来帮助你控制这些分布式服务之间的交互。Hystrix通过隔离服务之间的访问点，停止服务之间的级联故障并提供后备选项实现此目的，所有这些都可以提高系统的整体弹性。</p><p>总体来说[Hystrix]就是一个能进行熔断和降级的库，通过使用它能提高整个系统的弹性。</p><h1 id="什么是熔断和降级"><a href="#什么是熔断和降级" class="headerlink" title="什么是熔断和降级"></a>什么是熔断和降级</h1><p>举个例子，此时我们整个微服务系统是这样的。服务A调用了服务B，服务B在调用了服务C，但是因为某些原因，服务C顶不住了，这个时候大量请求会在服务C阻塞。</p><p><img src="/blogimg/640-20200430100748935.jpeg" alt="img"></p><p>服务C阻塞了还好，毕竟只是一个系统崩溃了。但是请注意这个时候因为服务C不能返回响应，那么服务B调用服务C的请求就会阻塞，同理服务B阻塞了，那么服务A夜壶一阻塞崩溃。</p><p>***  请注意，为什么阻塞会崩溃。因为这些请求会消耗占用系统的线程、IO等资源，消耗完系统服务器就崩了。</p><p><img src="/blogimg/640-20200430101129919.jpeg" alt="img"></p><p>这就叫服务雪崩。</p><p>所谓熔断就是服务雪崩的一种有效解决方案。当指定时间窗内的请求失败率达到设定阈值时，系统将通过断路器直接将此请求链路断开。</p><p>也就是我们上面服务B调用服务C在指定时间窗内，调用的失败率到达了一定的值，那么[Hystrix]则会自动讲服务B与C之间的请求都断了，以免导致服务雪崩现象。</p><p>其实这里所讲的熔断就是指的[Hystrix]中的断路器模式，</p><p>降级是为了更好的用户体验，当一个方法调用异常时，通过执行另一种代码逻辑来给用户友好的回复。这也就是对应着[Hystrix]后备处理模式。可以通过设置fallbackMethod来给一个方法设置备用的代码逻辑。比如这个时候有一个热点新闻出现了，我们会推荐给用户查看详情，然后用户会通过id去查看新闻的详情，但是因为这条新闻太火了，大量用户同时访问可能会导致系统崩溃，那么我么就进行服务降级，一些请求会做一些降级处理比如当前人数太多请稍后查看等等。</p><pre><code class="hljs less"><span class="hljs-comment">// 指定了后备方法调用</span><span class="hljs-variable">@HystrixCommand</span>(fallbackMethod = <span class="hljs-string">&quot;getHystrixNews&quot;</span>)<span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/get/news&quot;</span>)public News getNews(<span class="hljs-variable">@PathVariable</span>(<span class="hljs-string">&quot;id&quot;</span>) int id) &#123; <span class="hljs-comment">// 调用新闻系统的获取新闻api 代码逻辑省略*</span>&#125;<span class="hljs-comment">//</span>public News getHystrixNews(<span class="hljs-variable">@PathVariable</span>(<span class="hljs-string">&quot;id&quot;</span>) int id) &#123;  <span class="hljs-comment">// 做服务降级</span>  <span class="hljs-comment">// 返回当前人数太多，请稍后查看</span>&#125;</code></pre><h1 id="使用Feign-Hystrix"><a href="#使用Feign-Hystrix" class="headerlink" title="使用Feign Hystrix"></a>使用Feign Hystrix</h1><p>依然使用子模块：service-feign</p><p>pom文件不需要变化，因为spring-cloud-starter-openfeign已经自带了Hystrix。</p><p>修改配置文件application.yml,增加如下：</p><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span> <span class="hljs-attr">hystrix:</span>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><span class="hljs-comment"># 熔断器DashBoard: actuator在boot2.0调整后开关web端点的配置，*代表开启所有</span><span class="hljs-attr">management:</span>  <span class="hljs-attr">endpoints:</span>    <span class="hljs-attr">web:</span>      <span class="hljs-attr">exposure:</span>        <span class="hljs-attr">include:</span> <span class="hljs-string">&quot;*&quot;</span></code></pre><p>接着新建类ServiceHiHystrix继承ServiceHi接口，里面实现了失败下的返回信息：</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceHiHystrix</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServiceHi</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHiFromServiceHi</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + name + <span class="hljs-string">&quot;,this message send failed&quot;</span>;    &#125;&#125;</code></pre><p>更改ServiceHi接口，添加上fallback类为刚才新建的类：</p><pre><code class="hljs reasonml">@<span class="hljs-constructor">FeignClient(<span class="hljs-params">value</span> = <span class="hljs-string">&quot;data-server&quot;</span>,<span class="hljs-params">fallback</span> = ServiceHiHystrix.<span class="hljs-params">class</span>)</span></code></pre><p>启动server-feign，data-server和eureka-server测试。</p><p>打开：<a href="http://localhost:8765/hello/test%E3%80%82">http://localhost:8765/hello/test。</a></p><p><img src="/blogimg/image-20200430111215839.png" alt="image-20200430111215839"></p><p>接着，关掉服务提供者data-server，来模拟服务宕机的情况，重新访问：<a href="http://localhost:8765/hello/test%E3%80%82">http://localhost:8765/hello/test。</a></p><p><img src="/blogimg/image-20200430111259661.png" alt="image-20200430111259661"></p><p>返回了新建的错误信息。</p><h1 id="可视化熔断器监控Hystrix-Dashboard和Turbine"><a href="#可视化熔断器监控Hystrix-Dashboard和Turbine" class="headerlink" title="可视化熔断器监控Hystrix Dashboard和Turbine"></a>可视化熔断器监控Hystrix Dashboard和Turbine</h1><h2 id="Hystrix-Dashboard"><a href="#Hystrix-Dashboard" class="headerlink" title="Hystrix Dashboard"></a>Hystrix Dashboard</h2><p>Hystrix-dashboard是一款针对Hystrix进行实时监控的工具，通过Hystrix Dashboard我们可以在直观地看到各Hystrix Command的请求响应时间，请求成功率等数据。</p><p>在server-feign模块继续修改，上面已经在该模块添加了熔断器。</p><p>首先添加依赖：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-comment">&lt;!--spring boot 1.X：spring-cloud-starter-hystrix--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-comment">&lt;!--spring boot 1.X：spring-cloud-starter-hystrix-dashboard--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>启动类修改：</p><pre><code class="hljs less"><span class="hljs-variable">@EnableHystrixDashboard</span><span class="hljs-variable">@EnableCircuitBreaker</span></code></pre><p>启动工程访问：<a href="http://localhost:8765/hystrix%EF%BC%8C%E5%B0%86%E4%BC%9A%E7%9C%8B%E5%88%B0%E5%A6%82%E4%B8%8B%E7%95%8C%E9%9D%A2%EF%BC%9A">http://localhost:8765/hystrix，将会看到如下界面：</a></p><p><img src="/blogimg/image-20200430112702781.png" alt="image-20200430112702781"></p><p>图中会有一些提示：</p><ul><li>Cluster via Turbine (default cluster): <a href="http://turbine-hostname:port/turbine.stream">http://turbine-hostname:port/turbine.stream</a> </li><li>Cluster via Turbine (custom cluster): <a href="http://turbine-hostname:port/turbine.stream?cluster=[clusterName]">http://turbine-hostname:port/turbine.stream?cluster=[clusterName]</a></li><li>Single Hystrix App: <a href="http://hystrix-app:port/hystrix.stream">http://hystrix-app:port/hystrix.stream</a></li></ul><p>大概意思就是如果查看默认集群使用第一个url，查看指定集群使用第二个url，单个应用的监控使用最后一个，单个应用输入：<a href="http://localhost:8765/actuator/hystrix.stream%EF%BC%8C%E8%BE%93%E5%85%A5%E4%B9%8B%E5%90%8E%E7%82%B9%E5%87%BBmonitor%EF%BC%8C%E8%BF%9B%E5%85%A5%E9%A1%B5%E9%9D%A2%E3%80%82">http://localhost:8765/actuator/hystrix.stream，输入之后点击monitor，进入页面。</a></p><p>如果没有请求会先显示Loading …，访问<a href="http://localhost:9001/hystrix.stream">http://localhost:9001/hystrix.stream</a> 也会不断的显示ping。</p><p><img src="/blogimg/image-20200430113122523.png" alt="image-20200430113122523"></p><p>请求服务<a href="http://localhost:8765/hello/test%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E7%9B%91%E6%8E%A7%E7%9A%84%E6%95%88%E6%9E%9C%E4%BA%86%E3%80%82">http://localhost:8765/hello/test，就可以看到监控的效果了。</a></p><p><img src="/blogimg/image-20200430113400187.png" alt="image-20200430113400187"></p><p><img src="/blogimg/9428.png" alt="img"></p><p>到此单个应用的熔断监控已经完成了。</p><h1 id="Turbine"><a href="#Turbine" class="headerlink" title="Turbine"></a>Turbine</h1><p>只使用Hystrix Dashboard的话，只能看到单个应用内的服务信息，这明显不够，需要一个工具能让我们汇总系统内多个服务的数据并显示到Hystrix Dashboard上，这个工具就是Turbine。</p><p>在复杂的分布式系统中，相同服务的节点经常需要部署上百甚至上千个，很多时候，运维人员希望能够把相同服务的节点状态以一个整体集群的形式展现出来，这样可以更好的把握整个系统的状态。</p><p>注意：***</p><p>为了演示Turbine，在这里重新新建一个子模块，名为hystrix-dashboard-turbine。</p><p>创建新模块作为单独的监控节点模块，是因为演示dashboard的时候是耦合在了server-feign中，而Turbine需要同时监控多个服务消费者，把他耦合在一个消费者里显得不合时宜。</p><p>创建后，pom.xml中引入：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-comment">&lt;!--spring boot 1.X：spring-cloud-starter-hystrix-dashboard--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-netflix-turbine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>启动类中@EnableTurbine和@EnableHystrixDashboard：</p><pre><code class="hljs less"><span class="hljs-variable">@SpringBootApplication</span><span class="hljs-variable">@EnableTurbine</span><span class="hljs-variable">@EnableHystrixDashboard</span>public class HystrixDashboardTurbineApplication &#123;    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">static</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">main</span>(String[] args) &#123;        <span class="hljs-selector-tag">SpringApplication</span><span class="hljs-selector-class">.run</span>(HystrixDashboardTurbineApplication.class, args);    &#125;&#125;</code></pre><p>yml中：</p><pre><code class="hljs less"><span class="hljs-attribute">server</span>:  <span class="hljs-attribute">port</span>: <span class="hljs-number">8767</span><span class="hljs-attribute">spring</span>:  <span class="hljs-attribute">application</span>:    <span class="hljs-attribute">name</span>: hystrix-dashboard-turbine<span class="hljs-attribute">eureka</span>:  <span class="hljs-attribute">client</span>:    <span class="hljs-attribute">service-url</span>:      <span class="hljs-attribute">defaultZone</span>: <span class="hljs-attribute">http</span>:<span class="hljs-comment">//localhost:8761/eureka</span>#熔断器turbine<span class="hljs-attribute">turbine</span>:  <span class="hljs-attribute">aggregator</span>:    <span class="hljs-attribute">cluster-config</span>: default  <span class="hljs-attribute">cluster-name-expression</span>: new String(<span class="hljs-string">&quot;default&quot;</span>)  <span class="hljs-attribute">app-config</span>: service-feign,service-feign-<span class="hljs-number">2</span></code></pre><p>代码重点：***</p><ul><li><p>新模块端口号为：8767</p></li><li><p>turbine.appConfig ：配置Eureka中的serviceId列表，表明监控哪些服务（这里指定为SERVICE-FEIGN, SERVICE-FEIGN-2，稍后说）</p></li><li><p>turbine.aggregator.clusterConfig ：指定聚合哪些集群，多个使用”,”分割，默认为default。可使用http://…/turbine.stream?cluster={clusterConfig之一}访问</p></li><li><p>turbine.clusterNameExpression ：</p></li><li><ul><li>clusterNameExpression指定集群名称，默认表达式appName；此时：turbine.aggregator.clusterConfig需要配置想要监控的应用名称；</li><li>当clusterNameExpression: default时，turbine.aggregator.clusterConfig可以不写，因为默认就是default；</li><li>当clusterNameExpression: metadata[‘cluster’]时，假设想要监控的应用配置了eureka.instance.metadata-map.cluster: ABC，则需要配置，同时turbine.aggregator.clusterConfig: ABC</li></ul></li></ul><p>完成这些步骤后，我们还需要调整下服务提供者，我们需要两个服务提供者同时运行。</p><p> 将8765（service-feign）的服务提供者改为8766，名称改为：service-feign-2，运行起来，别忘了在运行设置中设置允许多个实例运行。修改后的service-feign的yml是：</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span> <span class="hljs-comment"># 服务端口号</span> <span class="hljs-attr">port:</span> <span class="hljs-number">8766</span><span class="hljs-attr">spring:</span> <span class="hljs-attr">application:</span>  <span class="hljs-comment"># 服务名，即serviceId</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">service-feign-2</span><span class="hljs-attr">eureka:</span> <span class="hljs-attr">client:</span>  <span class="hljs-attr">serviceUrl:</span>   <span class="hljs-comment"># 安全认证的服务注册中心地址</span>   <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8761/eureka</span><span class="hljs-comment"># 熔断器设置</span><span class="hljs-attr">feign:</span> <span class="hljs-attr">hystrix:</span>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><span class="hljs-comment"># 熔断器DashBoard: actuator在boot2.0调整后开关web端点的配置，*代表开启所有</span><span class="hljs-attr">management:</span> <span class="hljs-attr">endpoints:</span>  <span class="hljs-attr">web:</span>   <span class="hljs-attr">exposure:</span>    <span class="hljs-attr">include:</span> <span class="hljs-string">&quot;*&quot;</span></code></pre><p>访问：先<a href="http://localhost:8767/turbine.stream%EF%BC%8C%E5%9C%A8%E5%88%86%E5%88%AB%E8%AE%BF%E9%97%AEhttp://localhost:8765/hello/1232312%E3%80%81http://localhost:8766/hello/1232312">http://localhost:8767/turbine.stream，在分别访问http://localhost:8765/hello/1232312、http://localhost:8766/hello/1232312</a></p><p><img src="/blogimg/image-20200430155641667.png" alt="image-20200430155641667"></p><p>进行图形化监控查看，输入：<a href="http://localhost:8767/hystrix">http://localhost:8767/hystrix</a> ，返回酷酷的小熊界面，输入： <a href="http://localhost:8767/turbine.stream">http://localhost:8767/turbine.stream</a> ，然后点击 Monitor Stream ,可以看到出现了监控列表:</p><p><img src="/blogimg/image-20200430155816659.png" alt="image-20200430155816659"></p><p>上面只是一个监控。</p><h2 id="聚合监控列表："><a href="#聚合监控列表：" class="headerlink" title="聚合监控列表："></a>聚合监控列表：</h2><p>监控不同的服务熔断，首先得是不同的rpc调用，也就是消费者的熔断函数要是两个不同的，或者，消费者去调用的是两个不同的服务提供者！这样才会有多个监控表。</p><ul><li>新的消费目标（新的服务提供者）</li><li>或者是一个新的消费熔断器。</li></ul><p>修改server-feign子模块</p><p>1、ServiceHi接口的调用变为sayHiFromServiceHi2，value也指向另一个服务提供者data-server-2（新的消费目标（新的服务提供者））</p><pre><code class="hljs dart"><span class="hljs-meta">@FeignClient</span>(value = <span class="hljs-string">&quot;data-server-2&quot;</span>, fallback = ServiceHiHystrix.<span class="hljs-keyword">class</span>)public <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ServiceHi</span> </span>&#123;  <span class="hljs-comment"><span class="markdown">/<span class="hljs-strong">**</span></span></span><span class="hljs-comment"><span class="markdown">   \<span class="hljs-emphasis">* <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span>通过Feign伪Http客户端调用service-hi提供的服务<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span></span></span><span class="hljs-comment"><span class="markdown">  @GetMapping(&quot;/hi/&#123;name&#125;&quot;)</span></span><span class="hljs-comment"><span class="markdown">  String sayHiFromServiceHi2(@PathVariable(value = &quot;name&quot;) String name);</span></span><span class="hljs-comment"><span class="markdown">&#125;</span></span></code></pre><p>2、修改熔断器ServiceHiHystrix（新的消费熔断器）</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceHiHystrix</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServiceHi</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHiFromServiceHi2</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span> + name +<span class="hljs-string">&quot;, this message send failed. By Hystrix.&quot;</span>;    &#125;&#125;</code></pre><p>3、当然，随之更改的是HelloController，需要改为<code>return serviceHi.sayHiFromServiceHi2</code></p><pre><code class="hljs less"><span class="hljs-variable">@RestController</span>public class HelloController &#123;    <span class="hljs-comment">/** 注入服务&quot;service-hi&quot;的Feign客户端ServiceHi */</span>    <span class="hljs-variable">@Autowired</span>    private ServiceHi serviceHi;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 调用Feign客户端提供的服务，自带负载均衡</span><span class="hljs-comment">     * @param name</span><span class="hljs-comment">     * @return</span><span class="hljs-comment">     */</span>    <span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/hello/&#123;name&#125;&quot;</span>)    public String sayHi(<span class="hljs-variable">@PathVariable</span> String name)&#123;        <span class="hljs-comment">//调用Feign客户端ScheduleServiceHi的接口</span>        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">serviceHi</span><span class="hljs-selector-class">.sayHiFromServiceHi2</span>(name);    &#125;&#125;</code></pre><p>这样改完后，重启这个8766的服务消费者。</p><p>最后得到：</p><p><img src="/blogimg/image-20200430161110248.png" alt="image-20200430161110248"></p><ul><li>上方两排：不同的熔断器</li><li>下方两排：不同的消费提供者</li></ul>]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.远程调用服务</title>
    <link href="/2020/04/30/SpringCloud/4.%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1/"/>
    <url>/2020/04/30/SpringCloud/4.%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="1、需要三个角色"><a href="#1、需要三个角色" class="headerlink" title="1、需要三个角色"></a>1、需要三个角色</h1><p>服务注册中心（eureka-server）、服务提供者（data-server）、服务消费者，其中服务注册中心就是我们上一篇的Eureka单机版启动既可，流程是首先启动注册中心，服务提供者生产服务并注册到服务中心中，消费者从服务中心中获取服务并执行。</p><h1 id="服务提供者：使用data-server"><a href="#服务提供者：使用data-server" class="headerlink" title="服务提供者：使用data-server"></a>服务提供者：使用data-server</h1><p>子模块不需要做更改。</p><p>可以使用**@EnableDiscoveryClient代替@EnableEurekaClient**</p><h2 id="两者区别："><a href="#两者区别：" class="headerlink" title="两者区别："></a>两者区别：</h2><p>注解@EnableEurekaClient上有@EnableDiscoveryClient注解，可以说基本就是@EnableEurekaClient上有@EnableDiscoveryClient功能，另外上面的注释中提到，其实@EnableEurekaClient注解就是一种方便使用eureka的注解而已，可以说使用其他的注册中心后，都可以使用@EnableDiscoveryClient注解，但是使用@EnableEurekaClient的情景，就是在服务采用eureka作为注册中心的时候，使用场景较为单一。</p><h1 id="服务消费者：新建service-feign子模块"><a href="#服务消费者：新建service-feign子模块" class="headerlink" title="服务消费者：新建service-feign子模块"></a>服务消费者：新建service-feign子模块</h1><p>创建子模块service-feign</p><p>pom.xml</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.test.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.test.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>service-feign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>service-feign<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>服务消费者<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><h2 id="然后在主程序引入："><a href="#然后在主程序引入：" class="headerlink" title="然后在主程序引入："></a>然后在主程序引入：</h2><pre><code class="hljs less"><span class="hljs-variable">@EnableFeignClients</span><span class="hljs-variable">@EnableEurekaClient</span></code></pre><h2 id="之后，修改application-yml"><a href="#之后，修改application-yml" class="headerlink" title="之后，修改application.yml"></a>之后，修改application.yml</h2><pre><code class="hljs less"><span class="hljs-attribute">server</span>:  <span class="hljs-attribute">port</span>: <span class="hljs-number">8766</span><span class="hljs-attribute">spring</span>:  <span class="hljs-attribute">application</span>:    <span class="hljs-attribute">name</span>: service-feign-<span class="hljs-number">2</span><span class="hljs-attribute">eureka</span>:  <span class="hljs-attribute">client</span>:    <span class="hljs-attribute">service-url</span>:      <span class="hljs-attribute">defaultZone</span>: <span class="hljs-attribute">http</span>:<span class="hljs-comment">//localhost:8761/eureka</span></code></pre><h1 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h1><p>首先回顾一下data-server，它提供了一个上述eureka-hi服务提供了一个RESTful风格的接口：</p><p>TestController.java</p><pre><code class="hljs kotlin"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">    *  获取端口号</span><span class="hljs-comment">    * */</span>    <span class="hljs-meta">@Value(<span class="hljs-meta-string">&quot;<span class="hljs-subst">$&#123;server.port&#125;</span>&quot;</span>)</span>    <span class="hljs-keyword">private</span> String port;    <span class="hljs-comment">/*</span><span class="hljs-comment">    *  定义一个简单接口</span><span class="hljs-comment">    * */</span>    <span class="hljs-meta">@GetMapping(<span class="hljs-meta-string">&quot;/hi/&#123;name&#125;&quot;</span>)</span>    <span class="hljs-keyword">public</span> String home(<span class="hljs-meta">@PathVariable</span> String name)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hi &quot;</span> + name + <span class="hljs-string">&quot;,I am from port :&quot;</span> + port;    &#125;&#125;</code></pre><ul><li>行为：GET</li><li>资源：/hi/{name}</li></ul><p>在service-feign模块中编写调用data-server提供的接口的本地接口ServiceHi.java,如下：</p><pre><code class="hljs less"><span class="hljs-comment">/**</span><span class="hljs-comment"> * &lt;p&gt;一个Feign服务消费者接口&lt;/p&gt;</span><span class="hljs-comment"> **/</span><span class="hljs-variable">@FeignClient</span>(value = <span class="hljs-string">&quot;data-server&quot;</span>)public interface ServiceHi &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * &lt;p&gt;通过Feign伪Http客户端调用service-hi提供的服务&lt;/p&gt;</span><span class="hljs-comment">     **/</span>    <span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/hi/&#123;name&#125;&quot;</span>)    String sayHiFromServiceHi(<span class="hljs-variable">@PathVariable</span>(value = <span class="hljs-string">&quot;name&quot;</span>) String name);&#125;</code></pre><p>说明：</p><p>​    —通过@FeignClient标识当前接口是一个Feign客户端，<code>value = &quot;data-server&quot;</code>表示其针对的是名为data-server的服务。</p><p>​    — data-server则是我们data-server子模块的spring.application.name，这个name已经在eureka注册过。</p><p>​    — sayHiFromServiceHi方法为伪成Http客户端方法，与data-server的[GET] /hi/{name} 服务接口相对应。</p><p>之后，新建HelloController.java</p><pre><code class="hljs css"><span class="hljs-selector-tag">package</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.springcloud</span><span class="hljs-selector-class">.controller</span>;<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.springcloud</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.ServiceHi</span>;<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.beans</span><span class="hljs-selector-class">.factory</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.Autowired</span>;<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.bind</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.GetMapping</span>;<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.bind</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.PathVariable</span>;<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.bind</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.RestController</span>;<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">javax</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.Resource</span>;<span class="hljs-comment">/*</span><span class="hljs-comment">* 服务消费控制层</span><span class="hljs-comment">* */</span><span class="hljs-keyword">@RestController</span>public class HelloController &#123;    <span class="hljs-keyword">@Resource</span>    private ServiceHi serviceHi;    <span class="hljs-keyword">@GetMapping</span>(&quot;/hello/&#123;<span class="hljs-selector-tag">name</span>&#125;&quot;)    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">String</span> <span class="hljs-selector-tag">sayHi</span>(<span class="hljs-keyword">@PathVariable</span> String name)&#123;        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">serviceHi</span><span class="hljs-selector-class">.sayHiFromServiceHi</span>(<span class="hljs-selector-tag">name</span>);    &#125;&#125;</code></pre><p>重点：</p><p>​    —— serviceHi.sayHiFromServiceHi(name)即通过Feign调用伪Http客户端的服务接口。</p><p>已经全部配置完毕，依次启动eureka-server、data-server和service-feign。可以看到俩个服务都已经在eureka注册。</p><p>访问 <a href="http://localhost:8765/hello/test">http://localhost:8765/hello/test</a> ，即service-feign提供的服务接口。这个服务接口会通过Feign去调用服务data-server提供的服务接口。</p><p>在该调用中，Feign并不需要指定端口号，它并不知道这个方法所在的服务提供者现在在哪个端口运行，我们只需要向eureka寻求服务。</p><p>三个模块的拓扑图如下：</p><p><img src="/blogimg/640-8210992.png" alt="在这里插入图片描述"></p><h1 id="测试Feign负载均衡"><a href="#测试Feign负载均衡" class="headerlink" title="测试Feign负载均衡"></a>测试Feign负载均衡</h1><p>Feign会对服务调用进行负载平衡，需要同时打开两个data-server服务，由于在同一台电脑上，就得把端口号从8763改为8764，然后同时开启8763和8764两个服务。</p><p>要同时运行两个端口不同的相同服务，需要在run configuration里面把allow parallle打开：</p><p>可以看到有两个data-server进行了注册。</p><p>访问<a href="http://localhost:8765/hello/test%E3%80%82">http://localhost:8765/hello/test。</a></p><p>连续访问两次，发现两次会分别取调用data-server的两个服务节点。</p><p>最后是负载平衡的拓扑图：</p><p><img src="/blogimg/640-8211700.jpeg" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx配置</title>
    <link href="/2020/04/27/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/nginx%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/04/27/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/nginx%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h1><p>Nginx是一款轻量级的网页服务器、反向代理服务器。相较于Apache、lighttpd具有占有内存少，稳定性高等优势。<strong>它最常的用途是提供反向代理服务。</strong></p><h1 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h1><h2 id="a、准备工作"><a href="#a、准备工作" class="headerlink" title="a、准备工作"></a>a、准备工作</h2><p>Nginx的安装依赖于以下三个包，意思就是在安装Nginx之前首先必须安装一下的三个包，注意安装顺序如下：</p><p>　　1 SSL功能需要openssl库，直接通过yum安装: #yum install openssl</p><p>　　2 gzip模块需要zlib库，直接通过yum安装: #yum install zlib</p><p>　　3 rewrite模块需要pcre库，直接通过yum安装: #yum install pcre</p><h2 id="b、安装Nginx依赖项和Nginx"><a href="#b、安装Nginx依赖项和Nginx" class="headerlink" title="b、安装Nginx依赖项和Nginx"></a>b、安装Nginx依赖项和Nginx</h2><h3 id="1-使用yum安装nginx需要包括Nginx的库，安装Nginx的库"><a href="#1-使用yum安装nginx需要包括Nginx的库，安装Nginx的库" class="headerlink" title="　　1 使用yum安装nginx需要包括Nginx的库，安装Nginx的库"></a>　　1 使用yum安装nginx需要包括Nginx的库，安装Nginx的库</h3><p>　　　　#rpm -Uvh <a href="http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm">http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</a></p><h3 id="2-使用下面命令安装nginx"><a href="#2-使用下面命令安装nginx" class="headerlink" title="　　2 使用下面命令安装nginx"></a>　　2 使用下面命令安装nginx</h3><p>　　　　#yum install nginx</p><h3 id="3-启动Nginx"><a href="#3-启动Nginx" class="headerlink" title="　　3 启动Nginx"></a>　　3 启动Nginx</h3><p>　　　　#service nginx start</p><h1 id="3、直接浏览器访问localhost就会出现Nginx的欢迎界面表示安装成功，否则就是失败了"><a href="#3、直接浏览器访问localhost就会出现Nginx的欢迎界面表示安装成功，否则就是失败了" class="headerlink" title="3、直接浏览器访问localhost就会出现Nginx的欢迎界面表示安装成功，否则就是失败了"></a>3、直接浏览器访问localhost就会出现Nginx的欢迎界面表示安装成功，否则就是失败了</h1><p>　默认80端口加入防火墙访问白名单中：firewall-cmd –permanent –zone=public –add-port=80/tcp</p><p>　　使用firewall-cmd –reload命令使其生效</p><h1 id="4、配置Nginx"><a href="#4、配置Nginx" class="headerlink" title="4、配置Nginx"></a>4、配置Nginx</h1><pre><code class="hljs stata"><span class="hljs-keyword">cd</span> /usr/<span class="hljs-keyword">local</span>/nginx/<span class="hljs-keyword">conf</span><span class="hljs-keyword">ls</span>vi nginx.<span class="hljs-keyword">conf</span></code></pre><p>ls</p><p>vi nginx.con</p><p><img src="/blogimg/image-20200427091420834.png" alt="image-20200427091420834"></p><p>详细介绍：<a href="https://yq.aliyun.com/articles/700682">https://yq.aliyun.com/articles/700682</a></p>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器搭建</tag>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.穿件密码并登陆</title>
    <link href="/2020/04/27/%E6%9C%8D%E5%8A%A1%E5%99%A8/MySQL/1.%E5%88%9B%E5%BB%BA%E5%AF%86%E7%A0%81%E5%B9%B6%E7%99%BB%E9%99%86/"/>
    <url>/2020/04/27/%E6%9C%8D%E5%8A%A1%E5%99%A8/MySQL/1.%E5%88%9B%E5%BB%BA%E5%AF%86%E7%A0%81%E5%B9%B6%E7%99%BB%E9%99%86/</url>
    
    <content type="html"><![CDATA[<p>1、无密码</p><p>通过Yum安装的mysql的管理员账户是没有密码的，这里通过命令设置其密码为 <strong>admin</strong> </p><p><code>mysqladmin -u root password admin</code></p><p>2、登陆验证</p><p><code>mysql -uroot -padmin</code></p><p><code>show databases;</code></p><h1 id="卸载重装"><a href="#卸载重装" class="headerlink" title="卸载重装"></a>卸载重装</h1><p><a href="https://blog.csdn.net/u011262200/article/details/81049725">https://blog.csdn.net/u011262200/article/details/81049725</a></p><p>优秀解决问题：<a href="https://blog.csdn.net/luowenmin/article/details/81945548">https://blog.csdn.net/luowenmin/article/details/81945548</a></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器搭建</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.安装JDK</title>
    <link href="/2020/04/27/%E6%9C%8D%E5%8A%A1%E5%99%A8/JDK/1%E3%80%81%E5%AE%89%E8%A3%85JDK/"/>
    <url>/2020/04/27/%E6%9C%8D%E5%8A%A1%E5%99%A8/JDK/1%E3%80%81%E5%AE%89%E8%A3%85JDK/</url>
    
    <content type="html"><![CDATA[<p>1、安装JDK</p><p><code>yum -y install java-1.8.0-openjdk.x86_64</code></p><p>2、运行</p><p><code>java -version</code></p>]]></content>
    
    
    <categories>
      
      <category>JDK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0.安装mysql</title>
    <link href="/2020/04/27/%E6%9C%8D%E5%8A%A1%E5%99%A8/MySQL/0.%E5%AE%89%E8%A3%85mysql/"/>
    <url>/2020/04/27/%E6%9C%8D%E5%8A%A1%E5%99%A8/MySQL/0.%E5%AE%89%E8%A3%85mysql/</url>
    
    <content type="html"><![CDATA[<p>1、下载</p><pre><code class="hljs apache"><span class="hljs-attribute">cd</span> /tmp<span class="hljs-attribute">wget</span> http://repo.mysql.com/mysql-community-release-el<span class="hljs-number">7</span>-<span class="hljs-number">5</span>.noarch.rpm  <span class="hljs-attribute">rpm</span> -ivh mysql-community-release-el<span class="hljs-number">7</span>-<span class="hljs-number">5</span>.noarch.rpm</code></pre><p> 2、通过yum进行安装</p><p><code>yum install mysql mysql-server mysql-devel -y</code></p><p>3、启动</p><p><code>systemctl start mysql.service</code></p><p>4、验证</p><p>安装后会自动启动，启动后会占用3306端口。 使用如下命令查看3306端口是否启动，如果启动了则表示mysql处于运行状态。</p><p><code>netstat -anp|grep 3306</code></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器搭建</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.重启vsftpd服务器</title>
    <link href="/2020/04/25/%E6%9C%8D%E5%8A%A1%E5%99%A8/FTP/6.%E9%87%8D%E5%90%AFvsftpd%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2020/04/25/%E6%9C%8D%E5%8A%A1%E5%99%A8/FTP/6.%E9%87%8D%E5%90%AFvsftpd%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>1、重启使用vsftpd服务器</p><p>通常重启使用的命令是：</p><p><code>systemctl restart vsftpd.service</code></p><p>最后执行查看状态，以查看重启成功了：</p><p><code>systemctl status vsftpd.service</code></p><p>2、开放端口</p><p>a、端口概念</p><p>要访问Linux的端口，必须开通才行。</p><p>再买ECS服务器是，只开通了22和3389端口。22就是SecureCRT链接Linux服务器用的端口号。3389 是阿里云控制台链接用的端口，这里没有用到。</p><p>只有这两个端口号是不够用的，为了能够链接vsftpd服务器还需要开放21端口和 30000-30010端口</p><p>b、安全组</p><p>既然用的是阿里云，那么我们就借助阿里云的安全组操作来实现端口的开放效果。<br>登陆阿里云后，按照如下顺序选择：云服务器ECS-&gt;安全组-&gt;配置规则</p><p><img src="/images/blogimg/6977.png" alt="img"></p><p>c、当前安全组规则一览</p><p>目前安全组规则是3个，分别是22，3389和ICMP协议。</p><p>然后点右上角的 <strong>添加安全组规则</strong></p><p><img src="/images/blogimg/6978.png" alt="img"></p><p>d、添加21端口和30000-30010端口</p><p>如图所示只需要修改两个：<br>端口范围： 21/21 表示从21开始，到21结束<br>授权对象： 0.0.0.0/0 表示所有的ip地址都可以访问该端口，重复上述步骤</p><p><img src="/blogimg/6979.png" alt="img"></p><p>e、添加后安全组规则一览</p><p>如图所示，增加了两个新的规则</p><p><img src="/blogimg/6981.png" alt="img"></p><p>3、Transmit连接ftp</p><p><img src="/blogimg/image-20200425130914585.png" alt="image-20200425130914585"></p><p>上传下载拖拉移动。</p><p>上传文件路径：<code>/home/ftp/ftptest</code>也可以在该路径下自己创建新的文件夹。</p>]]></content>
    
    
    <categories>
      
      <category>FTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器搭建</tag>
      
      <tag>FTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.用户鉴权</title>
    <link href="/2020/04/25/%E6%9C%8D%E5%8A%A1%E5%99%A8/FTP/5.%E7%94%A8%E6%88%B7%E9%89%B4%E6%9D%83/"/>
    <url>/2020/04/25/%E6%9C%8D%E5%8A%A1%E5%99%A8/FTP/5.%E7%94%A8%E6%88%B7%E9%89%B4%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<p>1、关于鉴权</p><p>因为用户 ftptest 是 nologin的，所以存在鉴权的问题。 如果鉴权问题不解决，就是永不停息的 530错误</p><p>2、鉴权方式</p><p>a、pam.d/vsftpd文件</p><p><code>vi /etc/pam.d/vsftpd</code></p><p>注释掉/etc/pam.d/vsftpd文件里这一行：<br>#auth required pam_shells.so<br>这样不去鉴权，从而允许 ftptest 这种 nologin用户登录 ftp 服务器.</p><p>b、shells文件</p><p><code>vi /etc/shells</code></p><p>在/etc/shells文件里面增加一行：</p><p><code>/sbin/nologin</code></p><p>这样允许不能登录系统的用户通过鉴权</p><p><img src="/blogimg/image-20200425124837000.png" alt="image-20200425124837000"></p>]]></content>
    
    
    <categories>
      
      <category>FTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器搭建</tag>
      
      <tag>FTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.配置端口</title>
    <link href="/2020/04/25/%E6%9C%8D%E5%8A%A1%E5%99%A8/FTP/4.%E9%85%8D%E7%BD%AE%E7%AB%AF%E5%8F%A3/"/>
    <url>/2020/04/25/%E6%9C%8D%E5%8A%A1%E5%99%A8/FTP/4.%E9%85%8D%E7%BD%AE%E7%AB%AF%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<p>1、两种端口</p><p>vsftpd有两种端口，一个是21端口，用来监听客户端连接请求的。 这个一般说来是固定的，就一直使用21端口。<br>另一种是，一旦获取到请求之后，再专门用户服务端和客户端传输数据的端口。</p><p>2、配置端口</p><p>打开配置文件：</p><p> <code>vi /etc/vsftpd/vsftpd.conf</code><br>在最后添加：</p><pre><code class="hljs ini"><span class="hljs-attr">pasv_enable</span>=<span class="hljs-literal">YES</span><span class="hljs-attr">pasv_min_port</span>=<span class="hljs-number">30000</span><span class="hljs-attr">pasv_max_port</span>=<span class="hljs-number">30010</span></code></pre><p> 这表示使用被动模式，用于传输数据的端口分配从30000-30010之间。<br>在后续的Linux开放端口教程中也会做相应的配合工作。</p><p><img src="/blogimg/image-20200425124236426.png" alt="image-20200425124236426"></p>]]></content>
    
    
    <categories>
      
      <category>FTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器搭建</tag>
      
      <tag>FTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.配置用户</title>
    <link href="/2020/04/25/%E6%9C%8D%E5%8A%A1%E5%99%A8/FTP/3.%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7/"/>
    <url>/2020/04/25/%E6%9C%8D%E5%8A%A1%E5%99%A8/FTP/3.%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7/</url>
    
    <content type="html"><![CDATA[<p>1、配置用户</p><p>上面创建用户，接下来给vsftpd服务器中配置该用户</p><p>2、去掉匿名登录</p><p>默认情况下vsftpd服务器是允许匿名登录的，不安全。要关掉</p><p>首先通过vi命令打开ftp服务器配置文件：</p><p><code>vi /etc/vsftpd/vsftpd.conf</code></p><p>然后把本来的</p><p><code>anonymous_enable=YES</code><br>修改为</p><p><code>anonymous_enable=NO</code>修改完成之后，保存退出</p><p><img src="/blogimg/image-20200425092359061.png" alt="image-20200425092359061"></p><p>3、限制用户访问</p><p>为了不让刚才创建的用户，登录后随意切换到任意目录去，做限制，只允许访问<code>/home/ftp/ftptest</code>目录以及子目录。</p><p>配置方法：</p><p>首先通过vi命令打开ftp服务器配置文件：</p><p><code>vi /etc/vsftpd/vsftpd.conf</code></p><p>找到</p><pre><code class="hljs vala"><span class="hljs-meta">#chroot_list_enable=YES</span><span class="hljs-meta"># (default follows)</span><span class="hljs-meta">#chroot_list_file=/etc/vsftpd.chroot_list</span></code></pre><p>修改为：</p><pre><code class="hljs ini"><span class="hljs-attr">chroot_list_enable</span>=<span class="hljs-literal">YES</span><span class="hljs-comment"># (default follows)</span><span class="hljs-attr">chroot_list_file</span>=/etc/vsftpd/chroot_list</code></pre><p>chroot_list_enable=YES： 表示对用户访问进行限制<br>chroot_list_file=/etc/vsftpd/chroot_list 表示对chroot_list里面指定的用户进行限制 下一个步骤用户清单就会对chroot_list 这个文件进行编辑</p><p><img src="/blogimg/image-20200425093532375.png" alt="image-20200425093532375"></p><p>修改完成之后，保存退出。</p><p>4、用户清单</p><p>在chroot_list中添加ftptest用户</p><p>首先通过vi命令打开chroot_list文件(此文件本来是空的)：</p><p> <code>vi /etc/vsftpd/chroot_list</code></p><p>然后增加一行: ftptest</p><p><img src="/blogimg/image-20200425093833565.png" alt="/image-20200425093833565"></p><p>修改完成之后，保存退出。</p><p>5、允许写权限</p><p>vsftpd服务器是这样的，一旦某个用户被限制访问了，那么默认情况下，该用户的写权限也被剥夺了。 这就导致ftp客户端连接上服务器之后无法上传文件。<br>这个时候，就需要打开此用户的写权限，请按照如下办法操作：<br>首先通过vi命令打开ftp服务器配置文件：</p><p> <code>vi /etc/vsftpd/vsftpd.conf</code><br>在最后面新加一行：</p><p> <code>allow_writeable_chroot=YES</code></p><p><img src="/blogimg/image-20200425095349642.png" alt="image-20200425095349642"></p><p> 修改完成之后，保存退出。</p>]]></content>
    
    
    <categories>
      
      <category>FTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器搭建</tag>
      
      <tag>FTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.ftp用户</title>
    <link href="/2020/04/25/%E6%9C%8D%E5%8A%A1%E5%99%A8/FTP/2.ftp%E7%94%A8%E6%88%B7/"/>
    <url>/2020/04/25/%E6%9C%8D%E5%8A%A1%E5%99%A8/FTP/2.ftp%E7%94%A8%E6%88%B7/</url>
    
    <content type="html"><![CDATA[<p>1、用户概念</p><p>要连接上vsftpd服务器需要为Linux创建专门的用户。</p><p>2、用户目录</p><p>在Linux中，不同用户是有不同目录访问权限的，所以首先创建一个目录，作为这个ftp用户所拥有的目录。</p><p>Mkdir -p /home/ftp/ftptest</p><p>3、创建用户</p><p>执行如下命令，创建用户ftptest,并且指定其目录为用户目录创建的/home/ftp/ftptest</p><p>useradd -d /home/ftp/ftptest -g ftp -s /sbin/nologin ftptest</p><p>-g ftp表示该用户属于ftp分组（ftp分组是内置的，本来就存在，不需要自己创建）</p><p>-s /sbin/nologin表示这个用户不能用来登录secureCRT这样的客户端。这种不能登陆的用户又叫做虚拟用户，创建回给警告，别管</p><p>4、设置目录权限</p><p>chown -R ftptest /home/ftp/ftptest</p><p>chmod -R 775 /home/ftp/ftptest</p><p>把目录/home/wwwroot/ftptest的拥有者设置为ftptest<br>使ftptest用户拥有这个目录的读写权限</p><p>5、设置密码</p><p>为ftptest用户设置密码：passwd ftptest</p><p>出来提示输入密码。</p>]]></content>
    
    
    <categories>
      
      <category>FTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器搭建</tag>
      
      <tag>FTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.安装vfftpd</title>
    <link href="/2020/04/25/%E6%9C%8D%E5%8A%A1%E5%99%A8/FTP/1.%E5%AE%89%E8%A3%85vsftpd/"/>
    <url>/2020/04/25/%E6%9C%8D%E5%8A%A1%E5%99%A8/FTP/1.%E5%AE%89%E8%A3%85vsftpd/</url>
    
    <content type="html"><![CDATA[<p>1、介绍vsftpd</p><p>vsftpd 全称是：very secure FTP daemon 非常安全的ftp后台程序，及ftp 服务端</p><p>2、安装命令</p><p>yum install vsftpd -y</p><p>执行之后，最后看到Complete! 就表示安装成功了</p><p>3、查看服务启动状态</p><p>启动：systemctl start vsftpd.service</p><p>查看启动状态：systemctl status vsftpd.service</p><p><img src="/blogimg/image-20200425085048037.png" alt="image-20200425085048037"></p><p>关闭服务：systemctl stop vsftpd.service</p><p>检查端口：ftp服务启动的是21端口，使用如下命令应该观察到21端口正在处于监听状态，这也从侧面反应了ftp服务器启动成功了</p><p> netstat -anp|grep 21</p><p><img src="/blogimg/image-20200425085250752.png" alt="image-20200425085250752"></p>]]></content>
    
    
    <categories>
      
      <category>FTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器搭建</tag>
      
      <tag>FTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0.FTP介绍</title>
    <link href="/2020/04/24/%E6%9C%8D%E5%8A%A1%E5%99%A8/FTP/0.FTP%E4%BB%8B%E7%BB%8D/"/>
    <url>/2020/04/24/%E6%9C%8D%E5%8A%A1%E5%99%A8/FTP/0.FTP%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>1、ftp做什么用</p><p>Linux上安装ftp服务器。ftp的全称是File Transfer Protocol：文件传输协议。</p><p>实质ftp就是我们将本地的文件传输到服务器上，或者从服务器上下载文件用的。</p><p>2、安装服务器相关内容</p><p>Linux上的ftp服务器有各种型号，我们会使用vsftpd，全称是：very secure FTP daemon 非常安全的ftp后台程序。。。</p><p>为了使得这个服务器可以使用还要做许多配合工作，比如创建用户，配置端口，开放端口等等。</p>]]></content>
    
    
    <categories>
      
      <category>FTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器搭建 - FTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>远程连接服务器</title>
    <link href="/2020/04/24/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2020/04/24/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>Mac</p><p>软件：Termius、Transmit</p><p>方法：输入ssh root@localhost-&gt;输入密码</p>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器搭建 - 准备工作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查看购买的服务器</title>
    <link href="/2020/04/24/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/%E6%9F%A5%E7%9C%8B%E8%B4%AD%E4%B9%B0%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2020/04/24/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/%E6%9F%A5%E7%9C%8B%E8%B4%AD%E4%B9%B0%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>1、查看实例</p><p>点击云服务器ECS-&gt;实例 就可以看到已经购买的实例。 </p><p>2、查看ip</p><p>过一会儿就启动好了，就可以看到公网IP地址了。 后续访问这个服务器就是通过这个地址进行访问的。公有ip</p>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器搭建 - 准备工作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建服务器</title>
    <link href="/2020/04/24/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2020/04/24/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>1、阿里云购买</p><p><a href="http://aliyun.com/">http://aliyun.com/</a></p><p>2、购买ECS服务器-创建实例</p><p> ECS就是云服务器，进入控制台后，点击左边的云服务器ECS-&gt;实例-&gt;创建实例 进入购买新实例界面<br><strong>注：</strong> 默认是没有实例的，需要自己创建(购买)</p><p>3、购买ECS服务器-网络</p><p>使用默认设置，其中“请选择安全组” 必须手动指定为 “默认安全组” 。<br>所谓的安全组，就是指服务器开放什么端口让别人访问，默认只开放22和3389端口。<br>其他端口的开放，将在后续教程里在需要的时候讲解，这里采用默认即可。</p><p><strong>注：</strong> 公网IP地址采用：“分配” 这里有其他方案选择，不过不在本教程讨论范围之内。</p><p>一步一步</p><p>4、购买ECS服务器-镜像</p><p>镜像选择公共镜像，其中操作系统选择CentOS, 版本选择7.4 64位。</p><p>5、购买服务器-安全设置</p><p>安全设置，输入密码即可。-设置密码</p>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器搭建 - 准备工作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0.什么是springcloud</title>
    <link href="/2020/04/20/SpringCloud/0.%E4%BB%80%E4%B9%88%E6%98%AFspringcloud/"/>
    <url>/2020/04/20/SpringCloud/0.%E4%BB%80%E4%B9%88%E6%98%AFspringcloud/</url>
    
    <content type="html"><![CDATA[<p>首先看一张图：</p><p><img src="/blogimg/640.jpeg" alt="640"></p><p>什么是Spring Cloud：</p><p>Spring Cloud就是微服务系统架构的一站式解决方案，在平时我们构建微服务的过程中需要做如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等操作，而Spring Cloud为我们提供了一套简单的编程模型，使我们能在Spring Boot的基础上轻松地实现微服务项目的构建。</p><p>Spring Cloud的版本：</p><p>Spring Cloud的版本号是以英文单词，同时根据字母表的顺序对应版本时间顺序。</p><p>Spring Cloud的服务发现框架——Eureka</p><p>Eureka就是一个服务发现框架。</p><p>服务发现：其实就是一个“房产中介”，整个过程中有三个角色：服务提供者（出租房子的）、服务消费者（租客）、服务中介（房屋中介）。</p><p>服务提供者：就是一些自己能够执行的一些服务给外界。</p><p>服务消费者：就是需要使用一些服务的”用户“。</p><p>服务中介：其实就是服务提供者和服务消费者之间的”桥梁“，服务提供者可以把自己注册到服务中介那里，而服务消费者如需要消费一些服务（使用一些功能）就可以在服务中介中寻找注册在服务中介的服务提供者。</p><p>服务注册Register：</p><p>官方解释：当Eureka客户端向[Eureka] Server注册时，它提供自身的元数据，比如ip地址、端口，运行状况指示符URL，主页等。</p><p>结合中介理解：房东（提供者[Eureka] Client Provider）在中介（服务器[Eureka] Server）那里登记房屋的信息，比如面积，价格，地段等等（元数据metaDatea）。</p><p>服务续约Renew：</p><p>官方解释：Eureka客户会每隔30秒（默认情况下）发送一次心跳来续约。通过续约来告知[Eureka] Server该Eureka客户仍然存在，没有出现问题。正常情况下，如果[Eureka] Server在90秒没有收到Eureka客户的续约，它会将实例从其注册表中删除。</p><p>结合中介理解：房东（提供者[Eureka] Client provider）定期告诉中介（服务器[Eureka] Server）我的房子还租（续约），中介（服务器[Eureka] Server）收到之后继续保留房屋的信息。</p><p><strong>获取注册列表信息 Fetch Registries</strong>：</p><p>官方解释：Eureka 客户端从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务，从而进行远程调用。该注册列表信息定期（每30秒钟）更新一次。每次返回注册列表信息可能与 Eureka 客户端的缓存信息不同, Eureka 客户端自动处理。如果由于某种原因导致注册列表信息不能及时匹配，Eureka 客户端则会重新获取整个注册表信息。Eureka 服务器缓存注册列表信息，整个注册表以及每个应用程序的信息进行了压缩，压缩内容和没有压缩的内容完全相同。Eureka 客户端和 Eureka 服务器可以使用JSON / XML格式进行通讯。在默认的情况下 Eureka 客户端使用压缩<code>JSON</code>格式来获取注册列表的信息。</p><p>结合中介理解：租客(消费者<code>[Eureka] Client Consumer</code>) 去中介 (服务器<code>[Eureka] Server</code>) 那里获取所有的房屋信息列表 (客户端列表<code>[Eureka] Client List</code>) ，而且租客为了获取最新的信息会定期向中介 (服务器<code>[Eureka] Server</code>) 那里获取并更新本地列表。</p><p><strong>服务下线 Cancel</strong>：</p><p>官方解释：Eureka客户端在程序关闭时向Eureka服务器发送取消请求。发送请求后，该客户端实例信息将从服务器的实例注册表中删除。该下线请求不会自动完成，它需要调用以下内容：<code>DiscoveryManager.getInstance().shutdownComponent();</code></p><p>结合中介理解：房东 (提供者<code>[Eureka] Client Provider</code>) 告诉中介  (服务器<code>[Eureka] Server</code>) 我的房子不租了，中介之后就将注册的房屋信息从列表中剔除。</p><p><strong>获取注册列表信息 Fetch Registries</strong>：</p><p>官方解释：Eureka 客户端从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务，从而进行远程调用。该注册列表信息定期（每30秒钟）更新一次。每次返回注册列表信息可能与 Eureka 客户端的缓存信息不同, Eureka 客户端自动处理。如果由于某种原因导致注册列表信息不能及时匹配，Eureka 客户端则会重新获取整个注册表信息。Eureka 服务器缓存注册列表信息，整个注册表以及每个应用程序的信息进行了压缩，压缩内容和没有压缩的内容完全相同。Eureka 客户端和 Eureka 服务器可以使用JSON / XML格式进行通讯。在默认的情况下 Eureka 客户端使用压缩<code>JSON</code>格式来获取注册列表的信息。</p><p>结合中介理解：租客(消费者<code>[Eureka] Client Consumer</code>) 去中介 (服务器<code>[Eureka] Server</code>) 那里获取所有的房屋信息列表 (客户端列表<code>[Eureka] Client List</code>) ，而且租客为了获取最新的信息会定期向中介 (服务器<code>[Eureka] Server</code>) 那里获取并更新本地列表。</p><p><strong>服务下线 Cancel</strong>：</p><p>官方解释：Eureka客户端在程序关闭时向Eureka服务器发送取消请求。发送请求后，该客户端实例信息将从服务器的实例注册表中删除。该下线请求不会自动完成，它需要调用以下内容：<code>DiscoveryManager.getInstance().shutdownComponent();</code></p><p>结合中介理解：房东 (提供者<code>[Eureka] Client Provider</code>) 告诉中介  (服务器<code>[Eureka] Server</code>) 我的房子不租了，中介之后就将注册的房屋信息从列表中剔除。</p><p>下面就是<code>Netflix</code>官方给出的 Eureka 架构图，你会发现和我们前面画的中介图别无二致。</p><p><img src="/blogimg/640-2.jpeg" alt="640-2"></p><p>当然，可以充当服务发现的组件有很多：<code>Zookeeper</code>，<code>Consul</code>， <code>Eureka</code> 等。</p>]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.将Eureka改造为高可用集群单机</title>
    <link href="/2020/04/18/SpringCloud/3%E5%B0%86Eureka%E6%94%B9%E9%80%A0%E4%B8%BA%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/"/>
    <url>/2020/04/18/SpringCloud/3%E5%B0%86Eureka%E6%94%B9%E9%80%A0%E4%B8%BA%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="Eureka-Server的致命缺陷"><a href="#Eureka-Server的致命缺陷" class="headerlink" title="Eureka Server的致命缺陷"></a>Eureka Server的致命缺陷</h2><p>简单的服务注册中心Eureka Server与服务提供者Eureka Client的网络拓扑图</p><p><img src="/blogimg/640.png" alt="在这里插入图片描述"></p><p>这种配置方式有以下致命缺陷：</p><p>​    · 当成千上万的服务提供者都向它单节点的服务注册中心进行注册时，它的负载是非常高的。</p><p>​    · 一旦这个单节点的服务注册中心挂掉，则所有服务提供者的注册信息都将变得不可用</p><h2 id="创建eureka-ha子模块（high-available的缩写）"><a href="#创建eureka-ha子模块（high-available的缩写）" class="headerlink" title="创建eureka-ha子模块（high available的缩写）"></a>创建eureka-ha子模块（high available的缩写）</h2><p>创建单独的子模块eureka-ha</p><p>修改application.yml</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-comment"># 高可用节点1的配置</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8771</span><span class="hljs-attr">spring:</span>  <span class="hljs-comment"># 节点1的签名</span>  <span class="hljs-attr">profiles:</span>    <span class="hljs-attr">active:</span> <span class="hljs-string">peer1</span>  <span class="hljs-comment"># 服务名保持一致</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-ha</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">peer1</span>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">false</span>  <span class="hljs-attr">client:</span>    <span class="hljs-comment"># 进行注册（高可用配置、默认配置）</span>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">true</span>    <span class="hljs-comment"># 获取注册信息（高可用配置、默认配置）</span>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-comment"># 节点1向节点2、3进行服务注册</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8772/eureka/,http://localhost:8773/eureka/</span><span class="hljs-meta">---</span>  <span class="hljs-comment"># 高可用节点2的配置</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8772</span><span class="hljs-attr">spring:</span>  <span class="hljs-comment"># 节点2的签名</span>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">peer2</span>  <span class="hljs-comment"># 服务名保持一致</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-ha</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">peer2</span>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">false</span>  <span class="hljs-attr">client:</span>    <span class="hljs-comment"># 进行注册（高可用配置、默认配置）</span>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">true</span>    <span class="hljs-comment"># 获取注册信息（高可用配置、默认配置）</span>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-comment"># 节点2向节点1、3进行服务注册</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8771/eureka/,http://localhost:8773/eureka/</span><span class="hljs-meta">---</span><span class="hljs-comment"># 高可用节点3的配置</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8773</span><span class="hljs-attr">spring:</span>  <span class="hljs-comment"># 节点3的签名</span>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">peer3</span>  <span class="hljs-comment"># 服务名保持一致</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-ha</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">peer3</span>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">false</span>  <span class="hljs-attr">client:</span>    <span class="hljs-comment"># 进行注册（高可用配置、默认配置）</span>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">true</span>    <span class="hljs-comment"># 获取注册信息（高可用配置、默认配置）</span>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-comment"># 节点2向节点1、3进行服务注册</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8771/eureka/,http://localhost:8772/eureka/</span></code></pre><p>代码重点：</p><p>​    · 在yml文件中，通过—来区分多个文件，减少配置文件个数。</p><p>​    · 高可用配置中的节点，每个节点的端口号不同</p><p>​    · 高可用配置中的节点，所有节点的服务名相同，即spring.application.name相同</p><p>​    · 高可用配置中的节点，默认情况下，<code>register-with-eureka: true</code>、<code>fetch-registry: true</code></p><p>​    · 高可用配置中的节点，需要向除自己之外的节点进行服务注册</p><p>​    · 高可用配置中，设置了每个节点的标签</p><pre><code class="hljs dts"><span class="hljs-symbol">spring:</span>  <span class="hljs-meta"># 节点1的签名</span><span class="hljs-symbol">  profiles:</span><span class="hljs-symbol">    active:</span> peer1</code></pre><p>通过此标签来区分到底启动哪个配置页。</p><h2 id="修改EurekaHaApplication启动类"><a href="#修改EurekaHaApplication启动类" class="headerlink" title="修改EurekaHaApplication启动类"></a>修改EurekaHaApplication启动类</h2><p>和eureka一样，添加<code>@EnableEurekaServer</code></p><pre><code class="hljs groovy"><span class="hljs-keyword">package</span> com.test.springcloud;<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="hljs-keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;<span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableEurekaServer</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaHaApplication</span> &#123;</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;        SpringApplication.run(EurekaHaApplication.<span class="hljs-keyword">class</span>, args);    &#125;&#125;</code></pre><h2 id="启动三节点Eureka"><a href="#启动三节点Eureka" class="headerlink" title="启动三节点Eureka"></a>启动三节点Eureka</h2><p>因为是集群，所以要启动三个端口不同的实例，端口已经是yml文件中进行了设置。</p><p>在Edit configuration里自行设置三个运行配置，分别对应三个配置文件，注意图中箭头的设置。</p><p><img src="/blogimg/image-20200427134609618.png" alt="image-20200427134609618"></p><p><img src="/blogimg/640-7966406.jpeg" alt="在这里插入图片描述"></p><p>你也可以使用复制配置按钮：</p><p><img src="/blogimg/640-20200427135034775.jpeg" alt="在这里插入图片描述"></p><p>如果你发现Edit configuration里没有eureka-ha，请手动添加：</p><p><img src="/blogimg/640-20200427135108999.jpeg" alt="在这里插入图片描述"></p><p>最后，分别运行三个eureka-ha。</p><p>打开网页，输入 <a href="http://localhost:8771/">http://localhost:8771/</a> ， <a href="http://localhost:8772/">http://localhost:8772/</a> ，<a href="http://localhost:8773/">http://localhost:8773/</a></p>]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.创建服务提供者并在Eureka进行注册</title>
    <link href="/2020/04/15/SpringCloud/2.%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E5%B9%B6%E5%9C%A8Eureka%E8%BF%9B%E8%A1%8C%E6%B3%A8%E5%86%8C/"/>
    <url>/2020/04/15/SpringCloud/2.%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E5%B9%B6%E5%9C%A8Eureka%E8%BF%9B%E8%A1%8C%E6%B3%A8%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="创建子工程data-server"><a href="#创建子工程data-server" class="headerlink" title="创建子工程data-server"></a>创建子工程data-server</h1><p>配置pom.xml</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.test.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>data-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>data-server<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.test.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><p>配置启动类添加注解@EnableEurekaClient</p><pre><code class="hljs less"><span class="hljs-variable">@SpringBootApplication</span><span class="hljs-variable">@EnableEurekaClient</span>public class DataServerApplication &#123;    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">static</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">main</span>(String[] args) &#123;        <span class="hljs-selector-tag">SpringApplication</span><span class="hljs-selector-class">.run</span>(DataServerApplication.class, args);    &#125;&#125;</code></pre><p>配置application.yml</p><pre><code class="hljs yaml"><span class="hljs-comment"># 端口号</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8763</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">data-server</span><span class="hljs-comment"># 服务注册与发现相关配置</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-comment"># 服务注册地址</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8761/eureka/</span></code></pre><p>代码重点：</p><ul><li>defaultZone: <a href="http://localhost:8761/eureka/%EF%BC%8C">http://localhost:8761/eureka/，</a> 这里将该服务注册到localhost:8761</li></ul><p>写一个TestController.java</p><pre><code class="hljs kotlin"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">    *  获取端口号</span><span class="hljs-comment">    * */</span>    <span class="hljs-meta">@Value(<span class="hljs-meta-string">&quot;<span class="hljs-subst">$&#123;server.port&#125;</span>&quot;</span>)</span>    <span class="hljs-keyword">private</span> String port;    <span class="hljs-comment">/*</span><span class="hljs-comment">    *  定义一个简单接口</span><span class="hljs-comment">    * */</span>    <span class="hljs-meta">@GetMapping(<span class="hljs-meta-string">&quot;/hi/&#123;name&#125;&quot;</span>)</span>    <span class="hljs-keyword">public</span> String home(<span class="hljs-meta">@PathVariable</span> String name)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hi&quot;</span> + name + <span class="hljs-string">&quot;,I am from port :&quot;</span> + port;    &#125;&#125;</code></pre><p>代码重点：</p><ul><li>实现了一个简易的RESTful接口</li><li>添加@EnableEurekaClient</li></ul><p>启动俩个启动类：</p><p>查看:<a href="http://localhost:8761/">http://localhost:8761/</a></p><p>图片：</p><p>查看：<a href="http://localhost:8763/hi/rude3knife">http://localhost:8763/hi/rude3knife</a></p><p>图片</p>]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.父子项目搭建</title>
    <link href="/2020/04/15/SpringCloud/1.%E7%88%B6%E5%AD%90%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/04/15/SpringCloud/1.%E7%88%B6%E5%AD%90%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="主项目搭建-IDEA"><a href="#主项目搭建-IDEA" class="headerlink" title="主项目搭建-IDEA"></a>主项目搭建-IDEA</h1><p>先搭建SpringBoot+springcloud主体架构（注意版本对应）。</p><p>将父工程的src删除！没用，不会用到</p><p>父工程springcloudDemo</p><p>pom.xml</p><pre><code class="hljs dust"><span class="xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><span class="xml">  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.test.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span></span><span class="xml">  <span class="hljs-comment">&lt;!--子模块--&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span></span><span class="xml">  <span class="hljs-comment">&lt;!-- 父级：SpringBoot --&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">spring-cloud.version</span>&gt;</span>Hoxton.SR3<span class="hljs-tag">&lt;/<span class="hljs-name">spring-cloud.version</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></span><span class="xml">  <span class="hljs-comment">&lt;!--Spring Cloud 版本序列配置--&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;spring-cloud.version&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><span class="xml">    <span class="hljs-comment">&lt;!--Spring Boot 执行器组件--&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><span class="xml">    <span class="hljs-comment">&lt;!--Spring Cloud 基础--&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><span class="xml">    <span class="hljs-comment">&lt;!--Spring Cloud 服务注册组件--&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><span class="xml">      <span class="hljs-comment">&lt;!--此处的依赖是SpringBoot2.0以后专用的，如果您使用的SpringBoot版本低于2.0请使用spring-cloud-starter-eureka-server--&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><span class="xml">    <span class="hljs-comment">&lt;!--Spring Boot Web组件--&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><span class="xml">    <span class="hljs-comment">&lt;!--Spring Boot 测试组件--&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">pluginManagement</span>&gt;</span><span class="hljs-comment">&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!-- clean lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#clean_Lifecycle --&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-clean-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!-- default lifecycle, jar packaging: see https://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging --&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-resources-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.22.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-jar-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-install-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><span class="xml">        <span class="hljs-comment">&lt;!-- site lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#site_Lifecycle --&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-site-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.7.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-project-info-reports-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">pluginManagement</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></span></code></pre><h1 id="创建服务注册中心子工程eureka-server"><a href="#创建服务注册中心子工程eureka-server" class="headerlink" title="创建服务注册中心子工程eureka-server"></a>创建服务注册中心子工程eureka-server</h1><p>New module -&gt;next就行</p><p>在父工程中引入modules子模块</p><p><img src="/blogimg/image-20200415145101539-7361654.png" alt="image-20200415145101539"></p><p>在子工程中引入父工程依赖parent</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.test.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-comment">&lt;!--父工程依赖--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.test.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><p>启动程序***Application.java添加注解@EnableEurekaServer</p><pre><code class="hljs less"><span class="hljs-variable">@SpringBootApplication</span><span class="hljs-variable">@EnableEurekaServer</span>public class EurekaServerApplication &#123;    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">static</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">main</span>(String[] args) &#123;        <span class="hljs-selector-tag">SpringApplication</span><span class="hljs-selector-class">.run</span>(EurekaServerApplication.class, args);    &#125;&#125;</code></pre><p>配置application.yml</p><pre><code class="hljs yaml"><span class="hljs-comment"># 端口号</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8761</span><span class="hljs-comment"># 服务注册相关配置</span><span class="hljs-attr">eureka:</span>  <span class="hljs-comment"># 服务实例主机名</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">localhost</span>  <span class="hljs-comment"># 服务提供者配置</span>  <span class="hljs-attr">client:</span>    <span class="hljs-comment"># 不进行注册（当服务注册中心是单点而非高可用时的配置方式）</span>    <span class="hljs-attr">registerWithEureka:</span> <span class="hljs-literal">false</span>    <span class="hljs-comment"># 不获取注册信息（当服务注册中心是单点而非高可用时的配置方式）</span>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span>    <span class="hljs-comment"># 服务注册中心地址</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></code></pre><p>可以访问<a href="http://localhost:8761/">http://localhost:8761/</a></p>]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
